{"version":3,"file":"game-C5JinYmA.js","sources":["../../src/core/GameManager.ts","../../src/core/DrawingManager.ts","../../src/core/ScoreManager.ts"],"sourcesContent":["/**\n * GameManager class\n * Central coordinator for the handwriting exercise game\n */\n\nimport { DrawingManager } from './DrawingManager';\nimport { ScoreManager } from './ScoreManager';\nimport { StorageManager } from '../services/StorageManager';\nimport { AudioManager } from '../services/AudioManager';\nimport { UIManager } from '../services/UIManager';\nimport { Exercise, ConstraintBoxSize, ScoreResult, Point } from '../types/Exercise';\nimport { EventEmitter } from '../utils/EventEmitter';\n\n/**\n * GameManager options\n */\ninterface GameManagerOptions {\n  storageManager: StorageManager;\n  audioManager: AudioManager;\n  uiManager: UIManager;\n  drawingManager: DrawingManager;\n  scoreManager: ScoreManager;\n  container: HTMLElement;\n}\n\n/**\n * Game state\n */\ninterface GameState {\n  currentExercise: Exercise | null;\n  currentAttempt: number;\n  isPlaying: boolean;\n  isCreatingExercise: boolean;\n}\n\nexport class GameManager {\n  // Core managers\n  private storageManager: StorageManager;\n  private audioManager: AudioManager;\n  private uiManager: UIManager;\n  private drawingManager: DrawingManager;\n  private scoreManager: ScoreManager;\n\n  // Game state\n  private state: GameState = {\n    currentExercise: null,\n    currentAttempt: 0,\n    isPlaying: false,\n    isCreatingExercise: false,\n  };\n\n  // Constants\n  private readonly MAX_ATTEMPTS = 5;\n\n  /**\n   * Create a new GameManager\n   * @param options - Options for initializing the game manager\n   */\n  constructor(options: GameManagerOptions) {\n    this.storageManager = options.storageManager;\n    this.audioManager = options.audioManager;\n    this.uiManager = options.uiManager;\n    this.drawingManager = options.drawingManager;\n    this.scoreManager = options.scoreManager;\n\n    // Bind methods to maintain context\n    this.handleCreateExercise = this.handleCreateExercise.bind(this);\n    this.handleLoadExercise = this.handleLoadExercise.bind(this);\n    this.handleExerciseSelected = this.handleExerciseSelected.bind(this);\n    this.handleSaveExercise = this.handleSaveExercise.bind(this);\n    this.handleCancelExercise = this.handleCancelExercise.bind(this);\n    this.handleDoneButtonClicked = this.handleDoneButtonClicked.bind(this);\n    this.handleAttemptAnimationComplete = this.handleAttemptAnimationComplete.bind(this);\n    this.handleBackToMenu = this.handleBackToMenu.bind(this);\n    this.handleTryAgain = this.handleTryAgain.bind(this);\n    this.startNextAttempt = this.startNextAttempt.bind(this);\n  }\n\n  /**\n   * Initialize the game manager\n   */\n  public async initialize(): Promise<void> {\n    console.log('Initializing game manager...');\n\n    // Set up event listeners\n    this.setupEventListeners();\n\n    // Set up drawing canvas\n    this.setupDrawingCanvas();\n\n    return Promise.resolve();\n  }\n\n  /**\n   * Setup event listeners\n   */\n  private setupEventListeners(): void {\n    // UI Manager events\n    this.uiManager.on('create-template-clicked', this.handleCreateExercise);\n    this.uiManager.on('load-template-clicked', this.handleLoadExercise);\n    this.uiManager.on('exercise-selected', (exercise: unknown) =>\n      this.handleExerciseSelected(exercise as Exercise)\n    );\n    this.uiManager.on('save-exercise-clicked', (data: unknown) =>\n      this.handleSaveExercise(data as { name: string })\n    );\n    this.uiManager.on('cancel-exercise-clicked', this.handleCancelExercise);\n    this.uiManager.on('done-button-clicked', this.handleDoneButtonClicked);\n    this.uiManager.on('attempt-animation-complete', (attemptNumber: unknown) =>\n      this.handleAttemptAnimationComplete(attemptNumber as number)\n    );\n    this.uiManager.on('back-to-menu-clicked', this.handleBackToMenu);\n    this.uiManager.on('try-again-clicked', this.handleTryAgain);\n    this.uiManager.on('back-clicked', this.handleBackToMenu);\n    this.uiManager.on('star-added', (starCount: unknown) => {\n      this.audioManager.playStarSound(starCount as number);\n    });\n\n    // Drawing and Example Animation events (for sound)\n    let strokePauseTimer: ReturnType<typeof setTimeout> | null = null;\n    const PAUSE_DELAY = 120; // ms\n    let strokeSoundStarted = false;\n\n    const setupStrokeSoundListeners = (emitter: EventEmitter): void => {\n      emitter.on('stroke-started', () => {\n        strokeSoundStarted = false;\n      });\n      emitter.on('point-added', (...args) => {\n        const point = args[0] as Point;\n        if (point && typeof point.x === 'number' && typeof point.y === 'number') {\n          if (!strokeSoundStarted) {\n            this.audioManager.startStrokeSound(point.x, point.y);\n            strokeSoundStarted = true;\n          } else {\n            this.audioManager.updateStrokeSound(point.x, point.y);\n          }\n          this.audioManager.resumeStrokeSound();\n          if (strokePauseTimer) {\n            clearTimeout(strokePauseTimer);\n          }\n          strokePauseTimer = setTimeout(() => {\n            this.audioManager.pauseStrokeSound();\n          }, PAUSE_DELAY);\n        }\n      });\n      emitter.on('stroke-completed', () => {\n        if (strokePauseTimer) {\n          clearTimeout(strokePauseTimer);\n        }\n        this.audioManager.pauseStrokeSound();\n        this.audioManager.stopStrokeSound();\n        this.audioManager.playStrokeSound(); // keep the short beep for stroke end\n        strokeSoundStarted = false;\n      });\n    };\n\n    setupStrokeSoundListeners(this.drawingManager);\n    setupStrokeSoundListeners(this.uiManager);\n  }\n\n  /**\n   * Setup drawing canvas\n   */\n  private setupDrawingCanvas(): void {\n    // Set initial canvas for drawing manager\n    const canvas = document.querySelector('.drawing-canvas') as HTMLCanvasElement;\n    if (canvas) {\n      this.drawingManager.setCanvas(canvas);\n    }\n  }\n\n  /**\n   * Show the welcome screen\n   */\n  public showWelcomeScreen(): void {\n    // Reset state\n    this.state.currentExercise = null;\n    this.state.currentAttempt = 0;\n    this.state.isPlaying = false;\n    this.state.isCreatingExercise = false;\n\n    // Show welcome view\n    this.uiManager.showView('welcome');\n\n    // Play welcome sound\n    // this.audioManager.playWelcomeSound();\n  }\n\n  /**\n   * Handle create exercise button click\n   */\n  private handleCreateExercise(): void {\n    console.log('GameManager: handleCreateExercise - user requested to create new template');\n    // Update state\n    this.state.isCreatingExercise = true;\n\n    // Switch to create exercise view\n    this.uiManager.showView('create-exercise');\n\n    // Reset drawing manager\n    this.drawingManager.reset();\n\n    // Get drawing canvas from the UI\n    const canvas = document.querySelector(\n      '.create-exercise-view .drawing-canvas'\n    ) as HTMLCanvasElement;\n    if (canvas) {\n      // Ensure canvas is sized to its container for correct drawing resolution\n      const parent = canvas.parentElement;\n      if (parent) {\n        const rect = parent.getBoundingClientRect();\n        const ratio = window.devicePixelRatio || 1;\n        canvas.width = rect.width * ratio;\n        canvas.height = rect.height * ratio;\n        canvas.style.width = `${rect.width}px`;\n        canvas.style.height = `${rect.height}px`;\n        this.drawingManager.setCanvas(canvas);\n        this.drawingManager.enable();\n      }\n    }\n  }\n\n  /**\n   * Handle load exercise button click\n   */\n  private handleLoadExercise(): void {\n    console.log('GameManager: handleLoadExercise - fetching saved templates');\n    // Get exercises from storage\n    const exercises = this.storageManager.getExercises();\n    console.log(\n      `GameManager: handleLoadExercise - loaded ${exercises.length} templates`,\n      exercises\n    );\n\n    // Get thumbnails\n    const thumbnails: { [exerciseId: string]: string } = {};\n    exercises.forEach(exercise => {\n      const thumbnail = this.storageManager.getThumbnail(exercise.id);\n      if (thumbnail) {\n        thumbnails[exercise.id] = thumbnail;\n      }\n    });\n\n    // Update exercise list in UI\n    this.uiManager.updateExerciseList(exercises, thumbnails);\n\n    // Show exercise list view\n    this.uiManager.showView('exercise-list');\n  }\n\n  /**\n   * Handle exercise selection\n   * @param exercise - Selected exercise\n   */\n  public handleExerciseSelected(exercise: Exercise): void {\n    console.log(\n      `GameManager: handleExerciseSelected - starting game for template id=${exercise.id} name=\"${exercise.name}\"`\n    );\n    // Update state\n    this.state.currentExercise = exercise;\n    this.state.currentAttempt = 0;\n    this.state.isPlaying = true;\n\n    // Reset history display\n    this.uiManager.resetHistoryDisplay();\n\n    // Switch to attempt view first so the example container is laid out and measurable\n    this.uiManager.showView('attempt');\n\n    // Show example drawing now that the view is visible\n    this.uiManager.showExampleDrawing(exercise.adultDrawing);\n\n    // After animation completes, start the first attempt and remove this listener\n    const onExampleComplete = (): void => {\n      this.startNextAttempt();\n      this.uiManager.off('example-animation-complete', onExampleComplete);\n    };\n    this.uiManager.on('example-animation-complete', onExampleComplete);\n  }\n\n  /**\n   * Start the next attempt\n   */\n  private startNextAttempt(): void {\n    this.state.currentAttempt++;\n\n    if (this.state.currentAttempt > this.MAX_ATTEMPTS) {\n      this.showScoreScreen();\n      return;\n    }\n\n    // Calculate constraint box size for current attempt\n    const boxSize = this.calculateConstraintBoxSize(this.state.currentAttempt);\n\n    // Set up attempt view\n    this.uiManager.setupAttemptView(this.state.currentAttempt, boxSize);\n\n    // Get drawing canvas from the UI\n    const canvas = document.querySelector('.attempt-view .drawing-canvas') as HTMLCanvasElement;\n    if (canvas) {\n      this.drawingManager.setCanvas(canvas);\n      this.drawingManager.reset();\n      this.drawingManager.enable();\n    }\n\n    // Play attempt start sound\n    this.audioManager.playAttemptStartSound();\n  }\n\n  /**\n   * Handle done button click\n   */\n  private handleDoneButtonClicked(): void {\n    if (!this.state.currentExercise) {\n      return;\n    }\n\n    // Disable drawing\n    this.drawingManager.disable();\n\n    // Get drawing data\n    const drawingData = this.drawingManager.getDrawingData();\n\n    // Save attempt\n    if (\n      this.state.currentExercise &&\n      this.state.currentAttempt > 0 &&\n      this.state.currentAttempt <= this.MAX_ATTEMPTS\n    ) {\n      // Ensure attempts array has enough slots\n      while (this.state.currentExercise.attempts.length < this.state.currentAttempt) {\n        this.state.currentExercise.attempts.push({\n          strokes: [],\n          totalTime: 0,\n          width: 0,\n          height: 0,\n          created: Date.now(),\n        });\n      }\n\n      // Save current attempt\n      this.state.currentExercise.attempts[this.state.currentAttempt - 1] = drawingData;\n    }\n\n    // Play sound\n    this.audioManager.playAttemptCompleteSound();\n\n    // Animate drawing to history\n    this.uiManager.animateDrawingToHistory(this.state.currentAttempt, drawingData);\n  }\n\n  /**\n   * Handle attempt animation complete\n   * @param attemptNumber - Completed attempt number\n   */\n  private handleAttemptAnimationComplete(attemptNumber: number): void {\n    // Start next attempt or show score\n    if (attemptNumber >= this.MAX_ATTEMPTS) {\n      this.showScoreScreen();\n    } else {\n      this.startNextAttempt();\n    }\n  }\n\n  /**\n   * Show score screen after all attempts\n   */\n  private showScoreScreen(): void {\n    if (!this.state.currentExercise) {\n      return;\n    }\n\n    // Calculate score\n    const score = this.scoreManager.calculateScore(\n      this.state.currentExercise.adultDrawing,\n      this.state.currentExercise.attempts\n    );\n\n    // Save score to exercise\n    this.saveExerciseResult(this.state.currentExercise, score);\n\n    // Show score screen\n    this.uiManager.showScoreScreen(score);\n\n    // Play fanfare sound\n    this.audioManager.playFanfareSound();\n  }\n\n  /**\n   * Save exercise result\n   * @param exercise - Exercise with attempts\n   * @param score - Score result\n   */\n  private async saveExerciseResult(exercise: Exercise, score: ScoreResult): Promise<void> {\n    try {\n      await this.storageManager.saveExerciseResult(exercise, score);\n    } catch (error) {\n      console.error('Failed to save exercise result:', error);\n      this.uiManager.showError('Failed to save your score');\n    }\n  }\n\n  /**\n   * Handle save exercise button click\n   * @param data - Exercise data with name\n   */\n  private handleSaveExercise(data: { name: string }): void {\n    // Get drawing data\n    const drawingData = this.drawingManager.getDrawingData();\n\n    // Create new exercise\n    const exercise: Exercise = {\n      id: Date.now().toString(),\n      name: data.name,\n      createdAt: new Date(),\n      adultDrawing: drawingData,\n      attempts: [],\n      highestScore: null,\n    };\n\n    // Save exercise\n    this.storageManager\n      .saveExercise(exercise)\n      .then(() => {\n        // Show confirmation\n        this.uiManager.showExerciseSavedConfirmation();\n\n        // Back to welcome screen\n        setTimeout(() => {\n          this.state.isCreatingExercise = false;\n          this.uiManager.showView('welcome');\n        }, 1500);\n      })\n      .catch(error => {\n        console.error('Failed to save exercise:', error);\n        this.uiManager.showError('Failed to save exercise');\n      });\n  }\n\n  /**\n   * Handle cancel exercise button click\n   */\n  private handleCancelExercise(): void {\n    // Update state\n    this.state.isCreatingExercise = false;\n\n    // Return to welcome screen\n    this.uiManager.showView('welcome');\n  }\n\n  /**\n   * Handle back to menu button click\n   */\n  private handleBackToMenu(): void {\n    // Reset state\n    this.state.currentExercise = null;\n    this.state.currentAttempt = 0;\n    this.state.isPlaying = false;\n    this.state.isCreatingExercise = false;\n\n    // Clean up UI\n    this.uiManager.cleanupAnimations();\n    this.uiManager.resetHistoryDisplay();\n\n    // Return to welcome screen\n    this.uiManager.showView('welcome');\n  }\n\n  /**\n   * Handle try again button click\n   */\n  private handleTryAgain(): void {\n    if (!this.state.currentExercise) {\n      return;\n    }\n\n    // Keep the current exercise, reset attempt\n    this.state.currentAttempt = 0;\n\n    // Clean up UI\n    this.uiManager.resetHistoryDisplay();\n\n    // Switch to attempt view first so the example container is laid out and measurable\n    this.uiManager.showView('attempt');\n\n    // Show example drawing again (location/scale will be reset)\n    this.uiManager.showExampleDrawing(this.state.currentExercise.adultDrawing);\n\n    // After animation, start first attempt\n    this.uiManager.on('example-animation-complete', () => {\n      this.startNextAttempt();\n      // Remove this one-time listener\n      this.uiManager.off('example-animation-complete', this.startNextAttempt);\n    });\n  }\n\n  /**\n   * Calculate constraint box size for a given attempt\n   * @param attemptNumber - Current attempt number (1-5)\n   * @returns Constraint box size\n   */\n  private calculateConstraintBoxSize(attemptNumber: number): ConstraintBoxSize {\n    // Use viewport size for base, matching UIManager\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    const minDimension = Math.min(width, height);\n    const baseSize = minDimension * 0.6; // 60% of smaller dimension\n\n    // For the first attempt, use full base size; shrink only for subsequent attempts\n    const scaleFactor = attemptNumber === 1 ? 1 : Math.max(0.4, 1 - (attemptNumber - 1) * 0.01);\n\n    return {\n      width: baseSize * scaleFactor,\n      height: baseSize * scaleFactor,\n    };\n  }\n\n  /**\n   * Start the game with a specific exercise (template)\n   * @param exercise - Selected exercise\n   */\n  public startGameWithExercise(exercise: Exercise): void {\n    this.handleExerciseSelected(exercise);\n  }\n}\n","/**\n * DrawingManager class\n * Manages drawing operations on the canvas\n */\n\nimport { EventEmitter } from '../utils/EventEmitter';\nimport { StrokeData, DrawingData } from '../types/Exercise';\n\nexport class DrawingManager extends EventEmitter {\n  private canvas: HTMLCanvasElement | null = null;\n  private context: CanvasRenderingContext2D | null = null;\n  private isDrawing: boolean = false;\n  private isEnabled: boolean = false;\n  private currentStroke: StrokeData | null = null;\n  private strokes: StrokeData[] = [];\n  private strokeCounter: number = 0;\n  private startTime: number = 0;\n  private endTime: number = 0;\n  private strokeColor: string = '#000000';\n  private strokeWidth: number = 3;\n\n  /**\n   * Initialize the drawing manager and canvas\n   * @param canvasElement - Optional canvas element to use instead of creating one\n   */\n  public initialize(canvasElement?: HTMLCanvasElement): void {\n    if (canvasElement) {\n      this.canvas = canvasElement;\n    } else {\n      this.canvas = document.createElement('canvas');\n      this.canvas.classList.add('drawing-canvas');\n    }\n\n    this.context = this.canvas.getContext('2d');\n\n    if (!this.context) {\n      throw new Error('Could not get canvas context');\n    }\n\n    this.setupEventListeners();\n    this.reset();\n  }\n\n  /**\n   * Set up event listeners for touch/mouse events\n   */\n  private setupEventListeners(): void {\n    if (!this.canvas) {\n      return;\n    }\n\n    // Touch events for mobile/tablet\n    this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this));\n    this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this));\n    this.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this));\n\n    // Mouse events for desktop\n    this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));\n    this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));\n    this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));\n    this.canvas.addEventListener('mouseleave', this.handleMouseUp.bind(this));\n  }\n\n  /**\n   * Reset the drawing manager\n   */\n  public reset(): void {\n    this.strokes = [];\n    this.strokeCounter = 0;\n    this.startTime = 0;\n    this.endTime = 0;\n    this.isDrawing = false;\n    this.currentStroke = null;\n\n    if (this.canvas && this.context) {\n      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    }\n  }\n\n  /**\n   * Enable drawing\n   */\n  public enable(): void {\n    this.isEnabled = true;\n    if (this.canvas) {\n      this.canvas.style.pointerEvents = 'auto';\n    }\n  }\n\n  /**\n   * Disable drawing\n   */\n  public disable(): void {\n    this.isEnabled = false;\n    this.isDrawing = false;\n    this.currentStroke = null;\n    if (this.canvas) {\n      this.canvas.style.pointerEvents = 'none';\n    }\n  }\n\n  /**\n   * Set stroke color\n   * @param color - CSS color string\n   */\n  public setStrokeColor(color: string): void {\n    this.strokeColor = color;\n  }\n\n  /**\n   * Set stroke width\n   * @param width - Width in pixels\n   */\n  public setStrokeWidth(width: number): void {\n    this.strokeWidth = width;\n  }\n\n  /**\n   * Handle touch start event\n   * @param event - Touch event\n   */\n  private handleTouchStart(event: TouchEvent): void {\n    if (!this.isEnabled) return;\n\n    event.preventDefault();\n\n    const touch = event.touches[0];\n    this.startStroke(touch.clientX, touch.clientY, touch.force);\n  }\n\n  /**\n   * Handle touch move event\n   * @param event - Touch event\n   */\n  private handleTouchMove(event: TouchEvent): void {\n    if (!this.isEnabled || !this.isDrawing) return;\n\n    event.preventDefault();\n\n    const touch = event.touches[0];\n    this.continueStroke(touch.clientX, touch.clientY, touch.force);\n  }\n\n  /**\n   * Handle touch end event\n   * @param event - Touch event\n   */\n  private handleTouchEnd(event: TouchEvent): void {\n    if (!this.isEnabled) return;\n\n    event.preventDefault();\n    this.endStroke();\n  }\n\n  /**\n   * Handle mouse down event\n   * @param event - Mouse event\n   */\n  private handleMouseDown(event: MouseEvent): void {\n    if (!this.isEnabled) return;\n\n    event.preventDefault();\n    this.startStroke(event.clientX, event.clientY);\n  }\n\n  /**\n   * Handle mouse move event\n   * @param event - Mouse event\n   */\n  private handleMouseMove(event: MouseEvent): void {\n    if (!this.isEnabled || !this.isDrawing) return;\n\n    event.preventDefault();\n    this.continueStroke(event.clientX, event.clientY);\n  }\n\n  /**\n   * Handle mouse up event\n   * @param event - Mouse event\n   */\n  private handleMouseUp(event: MouseEvent): void {\n    if (!this.isEnabled) return;\n\n    event.preventDefault();\n    this.endStroke();\n  }\n\n  /**\n   * Start a new stroke\n   * @param x - X coordinate\n   * @param y - Y coordinate\n   * @param pressure - Optional pressure value\n   */\n  private startStroke(x: number, y: number, pressure: number = 1): void {\n    if (!this.canvas || !this.context) return;\n\n    // Get canvas-relative coordinates\n    const rect = this.canvas.getBoundingClientRect();\n    const pixelRatio = this.canvas.width / rect.width;\n    const canvasX = (x - rect.left) * pixelRatio;\n    const canvasY = (y - rect.top) * pixelRatio;\n\n    const now = Date.now();\n\n    // If this is the first stroke, record start time\n    if (this.strokes.length === 0) {\n      this.startTime = now;\n    }\n\n    this.isDrawing = true;\n\n    // Create a new stroke\n    this.currentStroke = {\n      id: this.strokeCounter++,\n      points: [\n        {\n          x: canvasX,\n          y: canvasY,\n          timestamp: now,\n          pressure: pressure,\n        },\n      ],\n      startTime: now,\n      endTime: now,\n      color: this.strokeColor,\n      width: this.strokeWidth,\n    };\n\n    // Setup drawing style\n    this.context.lineWidth = 3;\n    this.context.lineCap = 'round';\n    this.context.lineJoin = 'round';\n    this.context.strokeStyle = this.strokeColor;\n    this.context.beginPath();\n    this.context.moveTo(canvasX, canvasY);\n\n    // Emit stroke start event\n    this.emit('stroke-started', this.currentStroke);\n  }\n\n  /**\n   * Continue the current stroke\n   * @param x - X coordinate\n   * @param y - Y coordinate\n   * @param pressure - Optional pressure value\n   */\n  private continueStroke(x: number, y: number, pressure: number = 1): void {\n    if (!this.canvas || !this.context || !this.currentStroke) return;\n\n    // Get canvas-relative coordinates\n    const rect = this.canvas.getBoundingClientRect();\n    const pixelRatio = this.canvas.width / rect.width;\n    const canvasX = (x - rect.left) * pixelRatio;\n    const canvasY = (y - rect.top) * pixelRatio;\n\n    const now = Date.now();\n\n    // Add point to the current stroke\n    this.currentStroke.points.push({\n      x: canvasX,\n      y: canvasY,\n      timestamp: now,\n      pressure: pressure,\n    });\n\n    // Draw line to the new point\n    this.context.lineTo(canvasX, canvasY);\n    this.context.stroke();\n    this.context.beginPath();\n    this.context.moveTo(canvasX, canvasY);\n\n    // Emit point added event\n    this.emit('point-added', {\n      x: canvasX,\n      y: canvasY,\n      timestamp: now,\n      pressure,\n    });\n  }\n\n  /**\n   * End the current stroke\n   */\n  private endStroke(): void {\n    if (!this.currentStroke) return;\n\n    const now = Date.now();\n    this.currentStroke.endTime = now;\n    this.endTime = now;\n\n    // Add the completed stroke to the strokes array\n    this.strokes.push(this.currentStroke);\n\n    this.isDrawing = false;\n    this.currentStroke = null;\n\n    // Emit stroke completed event\n    this.emit('stroke-completed', this.strokes[this.strokes.length - 1]);\n  }\n\n  /**\n   * Set the canvas element for drawing\n   * @param canvas - Canvas element\n   */\n  public setCanvas(canvas: HTMLCanvasElement): void {\n    this.canvas = canvas;\n    this.context = canvas.getContext('2d');\n    this.setupEventListeners();\n  }\n\n  /**\n   * Get the current canvas element\n   */\n  public getCanvas(): HTMLCanvasElement | null {\n    return this.canvas;\n  }\n\n  /**\n   * Get drawing data\n   */\n  public getDrawingData(): DrawingData {\n    return {\n      strokes: [...this.strokes],\n      totalTime: this.endTime - this.startTime,\n      width: this.canvas?.width || 0,\n      height: this.canvas?.height || 0,\n      created: Date.now(),\n    };\n  }\n}\n","/**\n * ScoreManager class\n * Handles the scoring system for comparing drawings\n */\n\nimport { EventEmitter } from '../utils/EventEmitter';\nimport {\n  DrawingData,\n  StrokeData,\n  Point,\n  ScoreResult,\n  ScoreCategories,\n  ConstraintBoxSize,\n} from '../types/Exercise';\n\nexport class ScoreManager extends EventEmitter {\n  // Constants for scoring\n  private readonly MAX_SCORE = 100;\n\n  // Weights for different scoring categories\n  private readonly WEIGHTS = {\n    accuracy: 0.5, // 50% of total score\n    strokes: 0.25, // 25% of total score\n    timing: 0.25, // 25% of total score\n  };\n\n  // Feedback templates\n  private readonly FEEDBACK = {\n    excellent: [\n      'Excellent work! Your drawing is spot on!',\n      'Amazing job! Your handwriting is fantastic!',\n      \"Perfect! You've mastered this drawing!\",\n    ],\n    veryGood: [\n      'Very good! Your drawing looks great!',\n      'Impressive work! Keep practicing!',\n      \"Great job! You're getting better each time!\",\n    ],\n    good: [\n      \"Good job! You're making progress!\",\n      'Nice work! Keep practicing!',\n      \"Well done! You're improving!\",\n    ],\n    fair: [\n      'Nice try! Keep practicing!',\n      'Good effort! Try to follow the example more closely!',\n      'Keep going! Practice makes perfect!',\n    ],\n    needsWork: [\n      \"Keep practicing! You'll get better each time!\",\n      'Good start! Try to follow the example more carefully!',\n      \"Don't give up! Every practice helps you improve!\",\n    ],\n  };\n\n  /**\n   * Initialize the score manager\n   */\n  public initialize(): void {\n    // No initialization needed for now\n  }\n\n  /**\n   * Calculate scores for a completed exercise\n   * @param example - The adult's example drawing\n   * @param attempts - The child's attempt drawings (typically 5)\n   * @param constraintBoxes - Optional array of constraint boxes for each attempt\n   * @returns Score result with stars and feedback\n   */\n  public calculateScore(\n    example: DrawingData,\n    attempts: DrawingData[],\n    constraintBoxes?: ConstraintBoxSize[]\n  ): ScoreResult {\n    // We'll focus on the final attempt for the primary score\n    const finalAttempt = attempts[attempts.length - 1];\n\n    if (!finalAttempt) {\n      throw new Error('No attempts provided for scoring');\n    }\n\n    // 1. Calculate accuracy score (path similarity)\n    const accuracyScore = this.calculateAccuracyScore(\n      example,\n      finalAttempt,\n      constraintBoxes?.[attempts.length - 1]\n    );\n    console.log('accuracyScore', accuracyScore);\n\n    // 2. Calculate strokes score (number and length of strokes)\n    const strokesScore = this.calculateStrokesScore(example, finalAttempt);\n    console.log('strokesScore', strokesScore);\n\n    // 3. Calculate timing score (rhythm and pace of drawing)\n    const timingScore = this.calculateTimingScore(example, finalAttempt);\n    console.log('timingScore', timingScore);\n\n    // 4. Calculate overall score\n    const overallScore = Math.round(\n      (accuracyScore * this.WEIGHTS.accuracy +\n        strokesScore * this.WEIGHTS.strokes +\n        timingScore * this.WEIGHTS.timing) *\n        this.MAX_SCORE\n    );\n    console.log('overallScore', overallScore);\n\n    // 5. Convert normalized scores (0-1) to star ratings (1-5)\n    const categories: ScoreCategories = {\n      accuracy: this.normalizedScoreToStars(accuracyScore),\n      strokes: this.normalizedScoreToStars(strokesScore),\n      timing: this.normalizedScoreToStars(timingScore),\n      overall: this.normalizedScoreToStars(overallScore / this.MAX_SCORE),\n    };\n    console.log('categories', categories);\n\n    // 6. Generate feedback based on overall score\n    const feedback = this.generateFeedback(overallScore);\n    console.log('feedback', feedback);\n\n    // Create and return the complete score result\n    const scoreResult: ScoreResult = {\n      totalScore: overallScore,\n      categories,\n      feedback,\n      timestamp: Date.now(),\n    };\n    console.log('scoreResult', scoreResult);\n\n    // Emit score calculated event\n    this.emit('score-calculated', scoreResult);\n\n    return scoreResult;\n  }\n\n  /**\n   * Calculate accuracy score based on path similarity\n   * @param example - Example drawing\n   * @param attempt - Attempt drawing\n   * @param constraintBox - Optional constraint box size\n   * @returns Normalized score (0-1)\n   */\n  private calculateAccuracyScore(\n    example: DrawingData,\n    attempt: DrawingData,\n    constraintBox?: ConstraintBoxSize\n  ): number {\n    // First, normalize both drawings to same scale for comparison\n    const normalizedExample = this.normalizeDrawing(example);\n    const normalizedAttempt = this.normalizeDrawing(attempt);\n\n    // Prepare for scoring\n    let pathSimilarityScore = 0;\n    let constraintAdherenceScore = 1; // Default to perfect if no constraint box\n\n    // Calculate path similarity using Hausdorff distance\n    pathSimilarityScore = this.calculatePathSimilarity(normalizedExample, normalizedAttempt);\n\n    // If constraint box provided, check if strokes stayed inside\n    if (constraintBox) {\n      constraintAdherenceScore = this.calculateConstraintAdherence(attempt, constraintBox);\n    }\n\n    // Combine path similarity (75%) and constraint adherence (25%)\n    return pathSimilarityScore * 0.75 + constraintAdherenceScore * 0.25;\n  }\n\n  /**\n   * Calculate strokes score based on number and pattern of strokes\n   * @param example - Example drawing\n   * @param attempt - Attempt drawing\n   * @returns Normalized score (0-1)\n   */\n  private calculateStrokesScore(example: DrawingData, attempt: DrawingData): number {\n    // Compare stroke counts\n    const exampleStrokeCount = example.strokes.length;\n    const attemptStrokeCount = attempt.strokes.length;\n\n    // Calculate stroke count similarity (how close the counts are)\n    const countDifference = Math.abs(exampleStrokeCount - attemptStrokeCount);\n    const maxStrokes = Math.max(exampleStrokeCount, attemptStrokeCount);\n    const strokeCountScore = maxStrokes > 0 ? Math.max(0, 1 - countDifference / maxStrokes) : 1;\n\n    // Compare stroke lengths\n    const strokeLengthScore = this.compareStrokeLengths(example, attempt);\n\n    // Combine stroke count (50%) and stroke length (50%) scores\n    return strokeCountScore * 0.5 + strokeLengthScore * 0.5;\n  }\n\n  /**\n   * Calculate timing score based on rhythm and pace\n   * @param example - Example drawing\n   * @param attempt - Attempt drawing\n   * @returns Normalized score (0-1)\n   */\n  private calculateTimingScore(example: DrawingData, attempt: DrawingData): number {\n    // Compare total drawing time\n    const timingRatioScore = this.compareTimingRatio(example, attempt);\n\n    // Compare stroke timing patterns\n    const strokeTimingScore = this.compareStrokeTimingPatterns(example, attempt);\n\n    // Combine total time (40%) and stroke timing (60%) scores\n    return timingRatioScore * 0.4 + strokeTimingScore * 0.6;\n  }\n\n  /**\n   * Calculate path similarity between two drawings\n   * @param example - Normalized example drawing\n   * @param attempt - Normalized attempt drawing\n   * @returns Similarity score (0-1)\n   */\n  private calculatePathSimilarity(example: DrawingData, attempt: DrawingData): number {\n    // If either drawing has no strokes, return 0\n    if (example.strokes.length === 0 || attempt.strokes.length === 0) {\n      return 0;\n    }\n\n    // We'll use a simplified version of the Hausdorff distance\n    // Get all points from both drawings\n    const examplePoints = this.getAllPoints(example);\n    const attemptPoints = this.getAllPoints(attempt);\n\n    if (examplePoints.length === 0 || attemptPoints.length === 0) {\n      return 0;\n    }\n\n    // Calculate average minimum distance from attempt to example\n    let totalDistance = 0;\n\n    for (const attemptPoint of attemptPoints) {\n      // Find minimum distance to any example point\n      let minDistance = Number.MAX_VALUE;\n\n      for (const examplePoint of examplePoints) {\n        const distance = this.calculateDistance(attemptPoint, examplePoint);\n        minDistance = Math.min(minDistance, distance);\n      }\n\n      totalDistance += minDistance;\n    }\n\n    // Average minimum distance\n    const avgDistance = totalDistance / attemptPoints.length;\n\n    // Convert to similarity score (0-1)\n    // The smaller the distance, the higher the similarity\n    // Using an exponential decay function to convert distance to similarity\n    return Math.exp(-avgDistance * 5);\n  }\n\n  /**\n   * Calculate if strokes stay within constraint box\n   * @param attempt - Attempt drawing\n   * @param constraintBox - Constraint box size\n   * @returns Adherence score (0-1)\n   */\n  private calculateConstraintAdherence(\n    attempt: DrawingData,\n    constraintBox: ConstraintBoxSize\n  ): number {\n    // Count points outside constraint box\n    let totalPoints = 0;\n    let pointsOutside = 0;\n\n    // Center of the canvas (assuming constraint box is centered)\n    const centerX = attempt.width / 2;\n    const centerY = attempt.height / 2;\n\n    // Boundaries of constraint box\n    const leftBound = centerX - constraintBox.width / 2;\n    const rightBound = centerX + constraintBox.width / 2;\n    const topBound = centerY - constraintBox.height / 2;\n    const bottomBound = centerY + constraintBox.height / 2;\n\n    // Check each point in each stroke\n    for (const stroke of attempt.strokes) {\n      for (const point of stroke.points) {\n        totalPoints++;\n\n        // Check if point is outside constraint box\n        if (\n          point.x < leftBound ||\n          point.x > rightBound ||\n          point.y < topBound ||\n          point.y > bottomBound\n        ) {\n          pointsOutside++;\n        }\n      }\n    }\n\n    // Calculate adherence score (1 - percentage of points outside)\n    return totalPoints > 0 ? 1 - pointsOutside / totalPoints : 1;\n  }\n\n  /**\n   * Compare the length patterns of strokes\n   * @param example - Example drawing\n   * @param attempt - Attempt drawing\n   * @returns Similarity score (0-1)\n   */\n  private compareStrokeLengths(example: DrawingData, attempt: DrawingData): number {\n    // If either drawing has no strokes, return 0\n    if (example.strokes.length === 0 || attempt.strokes.length === 0) {\n      return 0;\n    }\n\n    // Calculate relative lengths of strokes in each drawing\n    const exampleLengths = this.calculateRelativeStrokeLengths(example);\n    const attemptLengths = this.calculateRelativeStrokeLengths(attempt);\n\n    // Compare stroke length patterns\n    // We'll use the minimum length of the two arrays\n    const minLength = Math.min(exampleLengths.length, attemptLengths.length);\n\n    if (minLength === 0) {\n      return 0;\n    }\n\n    let totalDifference = 0;\n\n    // Compare each stroke's relative length\n    for (let i = 0; i < minLength; i++) {\n      const lengthDifference = Math.abs(exampleLengths[i] - attemptLengths[i]);\n      totalDifference += lengthDifference;\n    }\n\n    // Add penalty for different number of strokes\n    const countDifference = Math.abs(exampleLengths.length - attemptLengths.length);\n    totalDifference += countDifference * 0.1; // Small penalty for each extra/missing stroke\n\n    // Calculate similarity score (0-1)\n    // The smaller the total difference, the higher the similarity\n    return Math.max(0, 1 - totalDifference / minLength);\n  }\n\n  /**\n   * Compare the total drawing time ratio\n   * @param example - Example drawing\n   * @param attempt - Attempt drawing\n   * @returns Similarity score (0-1)\n   */\n  private compareTimingRatio(example: DrawingData, attempt: DrawingData): number {\n    // If either drawing has no total time, return 0.5 (neutral score)\n    if (example.totalTime <= 0 || attempt.totalTime <= 0) {\n      return 0.5;\n    }\n\n    // Calculate ratio of attempt time to example time\n    const timeRatio = attempt.totalTime / example.totalTime;\n\n    // Ideal ratio is 1.0 (same time)\n    // Score decreases as ratio moves away from 1.0 in either direction\n    // Use a bell curve to score the ratio\n    return Math.exp(-Math.pow(Math.log(timeRatio), 2));\n  }\n\n  /**\n   * Compare timing patterns between strokes\n   * @param example - Example drawing\n   * @param attempt - Attempt drawing\n   * @returns Similarity score (0-1)\n   */\n  private compareStrokeTimingPatterns(example: DrawingData, attempt: DrawingData): number {\n    // If either drawing has too few strokes, return neutral score\n    if (example.strokes.length < 2 || attempt.strokes.length < 2) {\n      return 0.5;\n    }\n\n    // Calculate relative stroke durations\n    const exampleDurations = this.calculateRelativeStrokeDurations(example);\n    const attemptDurations = this.calculateRelativeStrokeDurations(attempt);\n\n    // Compare duration patterns\n    const minLength = Math.min(exampleDurations.length, attemptDurations.length);\n\n    if (minLength < 2) {\n      return 0.5;\n    }\n\n    let totalDifference = 0;\n\n    // Compare each stroke's relative duration\n    for (let i = 0; i < minLength; i++) {\n      const durationDifference = Math.abs(exampleDurations[i] - attemptDurations[i]);\n      totalDifference += durationDifference;\n    }\n\n    // Calculate similarity score (0-1)\n    return Math.max(0, 1 - totalDifference / minLength);\n  }\n\n  /**\n   * Calculate relative stroke lengths as proportions of total length\n   * @param drawing - Drawing data\n   * @returns Array of relative lengths (0-1)\n   */\n  private calculateRelativeStrokeLengths(drawing: DrawingData): number[] {\n    const lengths: number[] = [];\n    let totalLength = 0;\n\n    // Calculate length of each stroke\n    for (const stroke of drawing.strokes) {\n      let strokeLength = 0;\n\n      // Calculate length by summing distances between consecutive points\n      for (let i = 1; i < stroke.points.length; i++) {\n        const p1 = stroke.points[i - 1];\n        const p2 = stroke.points[i];\n        strokeLength += this.calculateDistance(p1, p2);\n      }\n\n      lengths.push(strokeLength);\n      totalLength += strokeLength;\n    }\n\n    // Calculate relative lengths (as proportion of total length)\n    return lengths.map(length => (totalLength > 0 ? length / totalLength : 0));\n  }\n\n  /**\n   * Calculate relative stroke durations as proportions of total time\n   * @param drawing - Drawing data\n   * @returns Array of relative durations (0-1)\n   */\n  private calculateRelativeStrokeDurations(drawing: DrawingData): number[] {\n    const durations: number[] = [];\n    let totalDuration = 0;\n\n    // Calculate duration of each stroke\n    for (const stroke of drawing.strokes) {\n      const duration = stroke.endTime - stroke.startTime;\n      durations.push(duration);\n      totalDuration += duration;\n    }\n\n    // Calculate relative durations (as proportion of total time)\n    return durations.map(duration => (totalDuration > 0 ? duration / totalDuration : 0));\n  }\n\n  /**\n   * Normalize drawing to common scale for comparison\n   * @param drawing - Drawing data to normalize\n   * @returns Normalized drawing data\n   */\n  private normalizeDrawing(drawing: DrawingData): DrawingData {\n    // If drawing is empty, return a copy as is\n    if (drawing.strokes.length === 0) {\n      return {\n        strokes: [],\n        totalTime: drawing.totalTime,\n        width: drawing.width,\n        height: drawing.height,\n        created: drawing.created,\n      };\n    }\n\n    // Find bounding box of the drawing\n    let minX = Number.MAX_VALUE;\n    let maxX = Number.MIN_VALUE;\n    let minY = Number.MAX_VALUE;\n    let maxY = Number.MIN_VALUE;\n\n    for (const stroke of drawing.strokes) {\n      for (const point of stroke.points) {\n        minX = Math.min(minX, point.x);\n        maxX = Math.max(maxX, point.x);\n        minY = Math.min(minY, point.y);\n        maxY = Math.max(maxY, point.y);\n      }\n    }\n\n    // Calculate dimensions and scale factor\n    const width = maxX - minX;\n    const height = maxY - minY;\n    const scale = width > 0 && height > 0 ? Math.min(1 / width, 1 / height) : 1;\n\n    // Create normalized strokes\n    const normalizedStrokes: StrokeData[] = drawing.strokes.map(stroke => {\n      // Create normalized points\n      const normalizedPoints: Point[] = stroke.points.map(point => {\n        return {\n          x: (point.x - minX) * scale,\n          y: (point.y - minY) * scale,\n          timestamp: point.timestamp,\n          pressure: point.pressure,\n        };\n      });\n\n      // Return normalized stroke\n      return {\n        id: stroke.id,\n        points: normalizedPoints,\n        startTime: stroke.startTime,\n        endTime: stroke.endTime,\n        color: stroke.color,\n        width: stroke.width,\n      };\n    });\n\n    // Return normalized drawing\n    return {\n      strokes: normalizedStrokes,\n      totalTime: drawing.totalTime,\n      width: 1, // Normalized to 0-1 range\n      height: height / width, // Maintain aspect ratio\n      created: drawing.created,\n    };\n  }\n\n  /**\n   * Get all points from a drawing as a flat array\n   * @param drawing - Drawing data\n   * @returns Array of all points\n   */\n  private getAllPoints(drawing: DrawingData): Point[] {\n    const points: Point[] = [];\n\n    for (const stroke of drawing.strokes) {\n      points.push(...stroke.points);\n    }\n\n    return points;\n  }\n\n  /**\n   * Calculate Euclidean distance between two points\n   * @param p1 - First point\n   * @param p2 - Second point\n   * @returns Distance between points\n   */\n  private calculateDistance(p1: Point, p2: Point): number {\n    const dx = p2.x - p1.x;\n    const dy = p2.y - p1.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  /**\n   * Convert normalized score (0-1) to star rating (1-5)\n   * @param score - Normalized score (0-1)\n   * @returns Star rating (1-5)\n   */\n  private normalizedScoreToStars(score: number): number {\n    // Ensure score is in range 0-1\n    const normalizedScore = Math.max(0, Math.min(1, score));\n\n    // Convert to star rating (1-5)\n    // Scale of 0-1 to 1-5: (score * 4) + 1\n    return Math.round(normalizedScore * 4 + 1);\n  }\n\n  /**\n   * Generate feedback message based on score\n   * @param score - Score out of 100\n   * @returns Feedback message\n   */\n  private generateFeedback(score: number): string {\n    // Select feedback template based on score\n    let feedbackCategory: keyof typeof this.FEEDBACK;\n\n    if (score >= 90) {\n      feedbackCategory = 'excellent';\n    } else if (score >= 75) {\n      feedbackCategory = 'veryGood';\n    } else if (score >= 60) {\n      feedbackCategory = 'good';\n    } else if (score >= 40) {\n      feedbackCategory = 'fair';\n    } else {\n      feedbackCategory = 'needsWork';\n    }\n\n    // Choose random feedback from selected category\n    const feedbackOptions = this.FEEDBACK[feedbackCategory];\n    const randomIndex = Math.floor(Math.random() * feedbackOptions.length);\n\n    return feedbackOptions[randomIndex];\n  }\n}\n"],"names":["GameManager","storageManager","audioManager","uiManager","drawingManager","scoreManager","state","currentExercise","currentAttempt","isPlaying","isCreatingExercise","MAX_ATTEMPTS","constructor","options","this","handleCreateExercise","bind","handleLoadExercise","handleExerciseSelected","handleSaveExercise","handleCancelExercise","handleDoneButtonClicked","handleAttemptAnimationComplete","handleBackToMenu","handleTryAgain","startNextAttempt","initialize","console","log","setupEventListeners","setupDrawingCanvas","Promise","resolve","on","exercise","data","attemptNumber","starCount","playStarSound","strokePauseTimer","strokeSoundStarted","setupStrokeSoundListeners","emitter","args","point","x","y","updateStrokeSound","startStrokeSound","resumeStrokeSound","clearTimeout","setTimeout","pauseStrokeSound","stopStrokeSound","playStrokeSound","canvas","document","querySelector","setCanvas","showWelcomeScreen","showView","reset","parent","parentElement","rect","getBoundingClientRect","ratio","window","devicePixelRatio","width","height","style","enable","exercises","getExercises","length","thumbnails","forEach","thumbnail","getThumbnail","id","updateExerciseList","name","resetHistoryDisplay","showExampleDrawing","adultDrawing","onExampleComplete","off","showScoreScreen","boxSize","calculateConstraintBoxSize","setupAttemptView","playAttemptStartSound","disable","drawingData","getDrawingData","attempts","push","strokes","totalTime","created","Date","now","playAttemptCompleteSound","animateDrawingToHistory","score","calculateScore","saveExerciseResult","playFanfareSound","error","showError","toString","createdAt","highestScore","saveExercise","then","showExerciseSavedConfirmation","catch","cleanupAnimations","innerWidth","innerHeight","baseSize","Math","min","scaleFactor","max","startGameWithExercise","DrawingManager","EventEmitter","context","isDrawing","isEnabled","currentStroke","strokeCounter","startTime","endTime","strokeColor","strokeWidth","canvasElement","createElement","classList","add","getContext","Error","addEventListener","handleTouchStart","handleTouchMove","handleTouchEnd","handleMouseDown","handleMouseMove","handleMouseUp","clearRect","pointerEvents","setStrokeColor","color","setStrokeWidth","event","preventDefault","touch","touches","startStroke","clientX","clientY","force","continueStroke","endStroke","pressure","pixelRatio","canvasX","left","canvasY","top","points","timestamp","lineWidth","lineCap","lineJoin","strokeStyle","beginPath","moveTo","emit","lineTo","stroke","getCanvas","ScoreManager","MAX_SCORE","WEIGHTS","accuracy","timing","FEEDBACK","excellent","veryGood","good","fair","needsWork","example","constraintBoxes","finalAttempt","accuracyScore","calculateAccuracyScore","strokesScore","calculateStrokesScore","timingScore","calculateTimingScore","overallScore","round","categories","normalizedScoreToStars","overall","feedback","generateFeedback","scoreResult","totalScore","attempt","constraintBox","normalizedExample","normalizeDrawing","normalizedAttempt","pathSimilarityScore","constraintAdherenceScore","calculatePathSimilarity","calculateConstraintAdherence","exampleStrokeCount","attemptStrokeCount","countDifference","abs","maxStrokes","compareStrokeLengths","compareTimingRatio","compareStrokeTimingPatterns","examplePoints","getAllPoints","attemptPoints","totalDistance","attemptPoint","minDistance","Number","MAX_VALUE","examplePoint","distance","calculateDistance","avgDistance","exp","totalPoints","pointsOutside","centerX","centerY","leftBound","rightBound","topBound","bottomBound","exampleLengths","calculateRelativeStrokeLengths","attemptLengths","minLength","totalDifference","i","timeRatio","pow","exampleDurations","calculateRelativeStrokeDurations","attemptDurations","drawing","lengths","totalLength","strokeLength","p1","p2","map","durations","totalDuration","duration","minX","maxX","MIN_VALUE","minY","maxY","scale","normalizedPoints","dx","dy","sqrt","normalizedScore","feedbackCategory","feedbackOptions","floor","random"],"mappings":"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"}