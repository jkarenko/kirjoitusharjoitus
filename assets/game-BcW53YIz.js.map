{"version":3,"file":"game-BcW53YIz.js","sources":["../../src/core/GameManager.ts","../../src/core/DrawingManager.ts","../../src/core/ScoreManager.ts"],"sourcesContent":["/**\n * GameManager class\n * Central coordinator for the handwriting exercise game\n */\n\nimport { DrawingManager } from './DrawingManager';\nimport { ScoreManager } from './ScoreManager';\nimport { StorageManager } from '../services/StorageManager';\nimport { AudioManager } from '../services/AudioManager';\nimport { UIManager } from '../services/UIManager';\nimport { Exercise, ConstraintBoxSize, ScoreResult } from '../types/Exercise';\n\n/**\n * GameManager options\n */\ninterface GameManagerOptions {\n  storageManager: StorageManager;\n  audioManager: AudioManager;\n  uiManager: UIManager;\n  drawingManager: DrawingManager;\n  scoreManager: ScoreManager;\n  container: HTMLElement;\n}\n\n/**\n * Game state\n */\ninterface GameState {\n  currentExercise: Exercise | null;\n  currentAttempt: number;\n  isPlaying: boolean;\n  isCreatingExercise: boolean;\n}\n\nexport class GameManager {\n  // Core managers\n  private storageManager: StorageManager;\n  private audioManager: AudioManager;\n  private uiManager: UIManager;\n  private drawingManager: DrawingManager;\n  private scoreManager: ScoreManager;\n\n  // Game state\n  private state: GameState = {\n    currentExercise: null,\n    currentAttempt: 0,\n    isPlaying: false,\n    isCreatingExercise: false,\n  };\n\n  // Constants\n  private readonly MAX_ATTEMPTS = 5;\n\n  /**\n   * Create a new GameManager\n   * @param options - Options for initializing the game manager\n   */\n  constructor(options: GameManagerOptions) {\n    this.storageManager = options.storageManager;\n    this.audioManager = options.audioManager;\n    this.uiManager = options.uiManager;\n    this.drawingManager = options.drawingManager;\n    this.scoreManager = options.scoreManager;\n\n    // Bind methods to maintain context\n    this.handleCreateExercise = this.handleCreateExercise.bind(this);\n    this.handleLoadExercise = this.handleLoadExercise.bind(this);\n    this.handleExerciseSelected = this.handleExerciseSelected.bind(this);\n    this.handleSaveExercise = this.handleSaveExercise.bind(this);\n    this.handleCancelExercise = this.handleCancelExercise.bind(this);\n    this.handleDoneButtonClicked = this.handleDoneButtonClicked.bind(this);\n    this.handleAttemptAnimationComplete = this.handleAttemptAnimationComplete.bind(this);\n    this.handleBackToMenu = this.handleBackToMenu.bind(this);\n    this.handleTryAgain = this.handleTryAgain.bind(this);\n    this.startNextAttempt = this.startNextAttempt.bind(this);\n  }\n\n  /**\n   * Initialize the game manager\n   */\n  public async initialize(): Promise<void> {\n    console.log('Initializing game manager...');\n\n    // Set up event listeners\n    this.setupEventListeners();\n\n    // Set up drawing canvas\n    this.setupDrawingCanvas();\n\n    return Promise.resolve();\n  }\n\n  /**\n   * Setup event listeners\n   */\n  private setupEventListeners(): void {\n    // UI Manager events\n    this.uiManager.on('create-template-clicked', this.handleCreateExercise);\n    this.uiManager.on('load-template-clicked', this.handleLoadExercise);\n    this.uiManager.on('exercise-selected', (exercise: unknown) =>\n      this.handleExerciseSelected(exercise as Exercise)\n    );\n    this.uiManager.on('save-exercise-clicked', (data: unknown) =>\n      this.handleSaveExercise(data as { name: string })\n    );\n    this.uiManager.on('cancel-exercise-clicked', this.handleCancelExercise);\n    this.uiManager.on('done-button-clicked', this.handleDoneButtonClicked);\n    this.uiManager.on('attempt-animation-complete', (attemptNumber: unknown) =>\n      this.handleAttemptAnimationComplete(attemptNumber as number)\n    );\n    this.uiManager.on('back-to-menu-clicked', this.handleBackToMenu);\n    this.uiManager.on('try-again-clicked', this.handleTryAgain);\n    this.uiManager.on('back-clicked', this.handleBackToMenu);\n    this.uiManager.on('star-added', (starCount: unknown) => {\n      this.audioManager.playStarSound(starCount as number);\n    });\n\n    // Drawing Manager events\n    this.drawingManager.on('stroke-completed', () => {\n      this.audioManager.playStrokeSound();\n    });\n  }\n\n  /**\n   * Setup drawing canvas\n   */\n  private setupDrawingCanvas(): void {\n    // Set initial canvas for drawing manager\n    const canvas = document.querySelector('.drawing-canvas') as HTMLCanvasElement;\n    if (canvas) {\n      this.drawingManager.setCanvas(canvas);\n    }\n  }\n\n  /**\n   * Show the welcome screen\n   */\n  public showWelcomeScreen(): void {\n    // Reset state\n    this.state.currentExercise = null;\n    this.state.currentAttempt = 0;\n    this.state.isPlaying = false;\n    this.state.isCreatingExercise = false;\n\n    // Show welcome view\n    this.uiManager.showView('welcome');\n\n    // Play welcome sound\n    this.audioManager.playWelcomeSound();\n  }\n\n  /**\n   * Handle create exercise button click\n   */\n  private handleCreateExercise(): void {\n    console.log('GameManager: handleCreateExercise - user requested to create new template');\n    // Update state\n    this.state.isCreatingExercise = true;\n\n    // Switch to create exercise view\n    this.uiManager.showView('create-exercise');\n\n    // Reset drawing manager\n    this.drawingManager.reset();\n\n    // Get drawing canvas from the UI\n    const canvas = document.querySelector(\n      '.create-exercise-view .drawing-canvas'\n    ) as HTMLCanvasElement;\n    if (canvas) {\n      // Ensure canvas is sized to its container for correct drawing resolution\n      const parent = canvas.parentElement;\n      if (parent) {\n        const rect = parent.getBoundingClientRect();\n        const ratio = window.devicePixelRatio || 1;\n        canvas.width = rect.width * ratio;\n        canvas.height = rect.height * ratio;\n        canvas.style.width = `${rect.width}px`;\n        canvas.style.height = `${rect.height}px`;\n        this.drawingManager.setCanvas(canvas);\n        this.drawingManager.enable();\n      }\n    }\n  }\n\n  /**\n   * Handle load exercise button click\n   */\n  private handleLoadExercise(): void {\n    console.log('GameManager: handleLoadExercise - fetching saved templates');\n    // Get exercises from storage\n    const exercises = this.storageManager.getExercises();\n    console.log(\n      `GameManager: handleLoadExercise - loaded ${exercises.length} templates`,\n      exercises\n    );\n\n    // Get thumbnails\n    const thumbnails: { [exerciseId: string]: string } = {};\n    exercises.forEach(exercise => {\n      const thumbnail = this.storageManager.getThumbnail(exercise.id);\n      if (thumbnail) {\n        thumbnails[exercise.id] = thumbnail;\n      }\n    });\n\n    // Update exercise list in UI\n    this.uiManager.updateExerciseList(exercises, thumbnails);\n\n    // Show exercise list view\n    this.uiManager.showView('exercise-list');\n  }\n\n  /**\n   * Handle exercise selection\n   * @param exercise - Selected exercise\n   */\n  public handleExerciseSelected(exercise: Exercise): void {\n    console.log(\n      `GameManager: handleExerciseSelected - starting game for template id=${exercise.id} name=\"${exercise.name}\"`\n    );\n    // Update state\n    this.state.currentExercise = exercise;\n    this.state.currentAttempt = 0;\n    this.state.isPlaying = true;\n\n    // Reset history display\n    this.uiManager.resetHistoryDisplay();\n\n    // Switch to attempt view first so the example container is laid out and measurable\n    this.uiManager.showView('attempt');\n\n    // Show example drawing now that the view is visible\n    this.uiManager.showExampleDrawing(exercise.adultDrawing);\n\n    // After animation completes, start the first attempt and remove this listener\n    const onExampleComplete = () => {\n      this.startNextAttempt();\n      this.uiManager.off('example-animation-complete', onExampleComplete);\n    };\n    this.uiManager.on('example-animation-complete', onExampleComplete);\n  }\n\n  /**\n   * Start the next attempt\n   */\n  private startNextAttempt(): void {\n    this.state.currentAttempt++;\n\n    if (this.state.currentAttempt > this.MAX_ATTEMPTS) {\n      this.showScoreScreen();\n      return;\n    }\n\n    // Calculate constraint box size for current attempt\n    const boxSize = this.calculateConstraintBoxSize(this.state.currentAttempt);\n\n    // Set up attempt view\n    this.uiManager.setupAttemptView(this.state.currentAttempt, boxSize);\n\n    // Get drawing canvas from the UI\n    const canvas = document.querySelector('.attempt-view .drawing-canvas') as HTMLCanvasElement;\n    if (canvas) {\n      this.drawingManager.setCanvas(canvas);\n      this.drawingManager.reset();\n      this.drawingManager.enable();\n    }\n\n    // Play attempt start sound\n    this.audioManager.playAttemptStartSound();\n  }\n\n  /**\n   * Handle done button click\n   */\n  private handleDoneButtonClicked(): void {\n    if (!this.state.currentExercise) return;\n\n    // Disable drawing\n    this.drawingManager.disable();\n\n    // Get drawing data\n    const drawingData = this.drawingManager.getDrawingData();\n\n    // Save attempt\n    if (\n      this.state.currentExercise &&\n      this.state.currentAttempt > 0 &&\n      this.state.currentAttempt <= this.MAX_ATTEMPTS\n    ) {\n      // Ensure attempts array has enough slots\n      while (this.state.currentExercise.attempts.length < this.state.currentAttempt) {\n        this.state.currentExercise.attempts.push({\n          strokes: [],\n          totalTime: 0,\n          width: 0,\n          height: 0,\n          created: Date.now(),\n        });\n      }\n\n      // Save current attempt\n      this.state.currentExercise.attempts[this.state.currentAttempt - 1] = drawingData;\n    }\n\n    // Play sound\n    this.audioManager.playAttemptCompleteSound();\n\n    // Animate drawing to history\n    this.uiManager.animateDrawingToHistory(this.state.currentAttempt, drawingData);\n  }\n\n  /**\n   * Handle attempt animation complete\n   * @param attemptNumber - Completed attempt number\n   */\n  private handleAttemptAnimationComplete(attemptNumber: number): void {\n    // Start next attempt or show score\n    if (attemptNumber >= this.MAX_ATTEMPTS) {\n      this.showScoreScreen();\n    } else {\n      this.startNextAttempt();\n    }\n  }\n\n  /**\n   * Show score screen after all attempts\n   */\n  private showScoreScreen(): void {\n    if (!this.state.currentExercise) return;\n\n    // Calculate score\n    const score = this.scoreManager.calculateScore(\n      this.state.currentExercise.adultDrawing,\n      this.state.currentExercise.attempts\n    );\n\n    // Save score to exercise\n    this.saveExerciseResult(this.state.currentExercise, score);\n\n    // Show score screen\n    this.uiManager.showScoreScreen(score);\n\n    // Play fanfare sound\n    this.audioManager.playFanfareSound();\n  }\n\n  /**\n   * Save exercise result\n   * @param exercise - Exercise with attempts\n   * @param score - Score result\n   */\n  private async saveExerciseResult(exercise: Exercise, score: ScoreResult): Promise<void> {\n    try {\n      await this.storageManager.saveExerciseResult(exercise, score);\n    } catch (error) {\n      console.error('Failed to save exercise result:', error);\n      this.uiManager.showError('Failed to save your score');\n    }\n  }\n\n  /**\n   * Handle save exercise button click\n   * @param data - Exercise data with name\n   */\n  private handleSaveExercise(data: { name: string }): void {\n    // Get drawing data\n    const drawingData = this.drawingManager.getDrawingData();\n\n    // Create new exercise\n    const exercise: Exercise = {\n      id: Date.now().toString(),\n      name: data.name,\n      createdAt: new Date(),\n      adultDrawing: drawingData,\n      attempts: [],\n      highestScore: null,\n    };\n\n    // Save exercise\n    this.storageManager\n      .saveExercise(exercise)\n      .then(() => {\n        // Show confirmation\n        this.uiManager.showExerciseSavedConfirmation();\n\n        // Back to welcome screen\n        setTimeout(() => {\n          this.state.isCreatingExercise = false;\n          this.uiManager.showView('welcome');\n        }, 1500);\n      })\n      .catch(error => {\n        console.error('Failed to save exercise:', error);\n        this.uiManager.showError('Failed to save exercise');\n      });\n  }\n\n  /**\n   * Handle cancel exercise button click\n   */\n  private handleCancelExercise(): void {\n    // Update state\n    this.state.isCreatingExercise = false;\n\n    // Return to welcome screen\n    this.uiManager.showView('welcome');\n  }\n\n  /**\n   * Handle back to menu button click\n   */\n  private handleBackToMenu(): void {\n    // Reset state\n    this.state.currentExercise = null;\n    this.state.currentAttempt = 0;\n    this.state.isPlaying = false;\n    this.state.isCreatingExercise = false;\n\n    // Clean up UI\n    this.uiManager.cleanupAnimations();\n    this.uiManager.resetHistoryDisplay();\n\n    // Return to welcome screen\n    this.uiManager.showView('welcome');\n  }\n\n  /**\n   * Handle try again button click\n   */\n  private handleTryAgain(): void {\n    if (!this.state.currentExercise) return;\n\n    // Keep the current exercise, reset attempt\n    this.state.currentAttempt = 0;\n\n    // Clean up UI\n    this.uiManager.resetHistoryDisplay();\n\n    // Show example drawing again\n    this.uiManager.showExampleDrawing(this.state.currentExercise.adultDrawing);\n\n    // After animation, start first attempt\n    this.uiManager.on('example-animation-complete', () => {\n      this.startNextAttempt();\n      // Remove this one-time listener\n      this.uiManager.off('example-animation-complete', this.startNextAttempt);\n    });\n\n    // Switch to attempt view\n    this.uiManager.showView('attempt');\n  }\n\n  /**\n   * Calculate constraint box size for a given attempt\n   * @param attemptNumber - Current attempt number (1-5)\n   * @returns Constraint box size\n   */\n  private calculateConstraintBoxSize(attemptNumber: number): ConstraintBoxSize {\n    // Base size (adjust based on screen size)\n    const baseSize = 300;\n\n    // Scale factor reduces by 15% for each attempt (100%, 85%, 70%, 55%, 40%)\n    const scaleFactor = Math.max(0.4, 1 - (attemptNumber - 1) * 0.15);\n\n    return {\n      width: baseSize * scaleFactor,\n      height: baseSize * scaleFactor,\n    };\n  }\n\n  /**\n   * Start the game with a specific exercise (template)\n   * @param exercise - Selected exercise\n   */\n  public startGameWithExercise(exercise: Exercise): void {\n    this.handleExerciseSelected(exercise);\n  }\n}\n","/**\n * DrawingManager class\n * Manages drawing operations on the canvas\n */\n\nimport { EventEmitter } from '../utils/EventEmitter';\nimport { StrokeData, DrawingData } from '../types/Exercise';\n\nexport class DrawingManager extends EventEmitter {\n  private canvas: HTMLCanvasElement | null = null;\n  private context: CanvasRenderingContext2D | null = null;\n  private isDrawing: boolean = false;\n  private isEnabled: boolean = false;\n  private currentStroke: StrokeData | null = null;\n  private strokes: StrokeData[] = [];\n  private strokeCounter: number = 0;\n  private startTime: number = 0;\n  private endTime: number = 0;\n  private strokeColor: string = '#000000';\n  private strokeWidth: number = 3;\n\n  /**\n   * Initialize the drawing manager and canvas\n   * @param canvasElement - Optional canvas element to use instead of creating one\n   */\n  public initialize(canvasElement?: HTMLCanvasElement): void {\n    if (canvasElement) {\n      this.canvas = canvasElement;\n    } else {\n      this.canvas = document.createElement('canvas');\n      this.canvas.classList.add('drawing-canvas');\n    }\n\n    this.context = this.canvas.getContext('2d');\n\n    if (!this.context) {\n      throw new Error('Could not get canvas context');\n    }\n\n    this.setupEventListeners();\n    this.reset();\n  }\n\n  /**\n   * Set up event listeners for touch/mouse events\n   */\n  private setupEventListeners(): void {\n    if (!this.canvas) {\n      return;\n    }\n\n    // Touch events for mobile/tablet\n    this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this));\n    this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this));\n    this.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this));\n\n    // Mouse events for desktop\n    this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));\n    this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));\n    this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));\n    this.canvas.addEventListener('mouseleave', this.handleMouseUp.bind(this));\n  }\n\n  /**\n   * Reset the drawing manager\n   */\n  public reset(): void {\n    this.strokes = [];\n    this.strokeCounter = 0;\n    this.startTime = 0;\n    this.endTime = 0;\n    this.isDrawing = false;\n    this.currentStroke = null;\n\n    if (this.canvas && this.context) {\n      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    }\n  }\n\n  /**\n   * Enable drawing\n   */\n  public enable(): void {\n    this.isEnabled = true;\n    if (this.canvas) {\n      this.canvas.style.pointerEvents = 'auto';\n    }\n  }\n\n  /**\n   * Disable drawing\n   */\n  public disable(): void {\n    this.isEnabled = false;\n    this.isDrawing = false;\n    this.currentStroke = null;\n    if (this.canvas) {\n      this.canvas.style.pointerEvents = 'none';\n    }\n  }\n\n  /**\n   * Set stroke color\n   * @param color - CSS color string\n   */\n  public setStrokeColor(color: string): void {\n    this.strokeColor = color;\n  }\n\n  /**\n   * Set stroke width\n   * @param width - Width in pixels\n   */\n  public setStrokeWidth(width: number): void {\n    this.strokeWidth = width;\n  }\n\n  /**\n   * Handle touch start event\n   * @param event - Touch event\n   */\n  private handleTouchStart(event: TouchEvent): void {\n    if (!this.isEnabled) return;\n\n    event.preventDefault();\n\n    const touch = event.touches[0];\n    this.startStroke(touch.clientX, touch.clientY, touch.force);\n  }\n\n  /**\n   * Handle touch move event\n   * @param event - Touch event\n   */\n  private handleTouchMove(event: TouchEvent): void {\n    if (!this.isEnabled || !this.isDrawing) return;\n\n    event.preventDefault();\n\n    const touch = event.touches[0];\n    this.continueStroke(touch.clientX, touch.clientY, touch.force);\n  }\n\n  /**\n   * Handle touch end event\n   * @param event - Touch event\n   */\n  private handleTouchEnd(event: TouchEvent): void {\n    if (!this.isEnabled) return;\n\n    event.preventDefault();\n    this.endStroke();\n  }\n\n  /**\n   * Handle mouse down event\n   * @param event - Mouse event\n   */\n  private handleMouseDown(event: MouseEvent): void {\n    if (!this.isEnabled) return;\n\n    event.preventDefault();\n    this.startStroke(event.clientX, event.clientY);\n  }\n\n  /**\n   * Handle mouse move event\n   * @param event - Mouse event\n   */\n  private handleMouseMove(event: MouseEvent): void {\n    if (!this.isEnabled || !this.isDrawing) return;\n\n    event.preventDefault();\n    this.continueStroke(event.clientX, event.clientY);\n  }\n\n  /**\n   * Handle mouse up event\n   * @param event - Mouse event\n   */\n  private handleMouseUp(event: MouseEvent): void {\n    if (!this.isEnabled) return;\n\n    event.preventDefault();\n    this.endStroke();\n  }\n\n  /**\n   * Start a new stroke\n   * @param x - X coordinate\n   * @param y - Y coordinate\n   * @param pressure - Optional pressure value\n   */\n  private startStroke(x: number, y: number, pressure: number = 1): void {\n    if (!this.canvas || !this.context) return;\n\n    // Get canvas-relative coordinates\n    const rect = this.canvas.getBoundingClientRect();\n    const canvasX = x - rect.left;\n    const canvasY = y - rect.top;\n\n    const now = Date.now();\n\n    // If this is the first stroke, record start time\n    if (this.strokes.length === 0) {\n      this.startTime = now;\n    }\n\n    this.isDrawing = true;\n\n    // Create a new stroke\n    this.currentStroke = {\n      id: this.strokeCounter++,\n      points: [\n        {\n          x: canvasX,\n          y: canvasY,\n          timestamp: now,\n          pressure: pressure,\n        },\n      ],\n      startTime: now,\n      endTime: now,\n      color: this.strokeColor,\n      width: this.strokeWidth,\n    };\n\n    // Setup drawing style\n    this.context.lineWidth = 3;\n    this.context.lineCap = 'round';\n    this.context.lineJoin = 'round';\n    this.context.strokeStyle = this.strokeColor;\n    this.context.beginPath();\n    this.context.moveTo(canvasX, canvasY);\n\n    // Emit stroke start event\n    this.emit('stroke-started', this.currentStroke);\n  }\n\n  /**\n   * Continue the current stroke\n   * @param x - X coordinate\n   * @param y - Y coordinate\n   * @param pressure - Optional pressure value\n   */\n  private continueStroke(x: number, y: number, pressure: number = 1): void {\n    if (!this.canvas || !this.context || !this.currentStroke) return;\n\n    // Get canvas-relative coordinates\n    const rect = this.canvas.getBoundingClientRect();\n    const canvasX = x - rect.left;\n    const canvasY = y - rect.top;\n\n    const now = Date.now();\n\n    // Add point to the current stroke\n    this.currentStroke.points.push({\n      x: canvasX,\n      y: canvasY,\n      timestamp: now,\n      pressure: pressure,\n    });\n\n    // Draw line to the new point\n    this.context.lineTo(canvasX, canvasY);\n    this.context.stroke();\n    this.context.beginPath();\n    this.context.moveTo(canvasX, canvasY);\n\n    // Emit point added event\n    this.emit('point-added', {\n      x: canvasX,\n      y: canvasY,\n      timestamp: now,\n      pressure,\n    });\n  }\n\n  /**\n   * End the current stroke\n   */\n  private endStroke(): void {\n    if (!this.currentStroke) return;\n\n    const now = Date.now();\n    this.currentStroke.endTime = now;\n    this.endTime = now;\n\n    // Add the completed stroke to the strokes array\n    this.strokes.push(this.currentStroke);\n\n    this.isDrawing = false;\n    this.currentStroke = null;\n\n    // Emit stroke completed event\n    this.emit('stroke-completed', this.strokes[this.strokes.length - 1]);\n  }\n\n  /**\n   * Set the canvas element for drawing\n   * @param canvas - Canvas element\n   */\n  public setCanvas(canvas: HTMLCanvasElement): void {\n    this.canvas = canvas;\n    this.context = canvas.getContext('2d');\n    this.setupEventListeners();\n  }\n\n  /**\n   * Get the current canvas element\n   */\n  public getCanvas(): HTMLCanvasElement | null {\n    return this.canvas;\n  }\n\n  /**\n   * Get drawing data\n   */\n  public getDrawingData(): DrawingData {\n    return {\n      strokes: [...this.strokes],\n      totalTime: this.endTime - this.startTime,\n      width: this.canvas?.width || 0,\n      height: this.canvas?.height || 0,\n      created: Date.now(),\n    };\n  }\n}\n","/**\n * ScoreManager class\n * Handles the scoring system for comparing drawings\n */\n\nimport { EventEmitter } from '../utils/EventEmitter';\nimport {\n  DrawingData,\n  StrokeData,\n  Point,\n  ScoreResult,\n  ScoreCategories,\n  ConstraintBoxSize,\n} from '../types/Exercise';\n\nexport class ScoreManager extends EventEmitter {\n  // Constants for scoring\n  private readonly MAX_SCORE = 100;\n\n  // Weights for different scoring categories\n  private readonly WEIGHTS = {\n    accuracy: 0.5, // 50% of total score\n    strokes: 0.25, // 25% of total score\n    timing: 0.25, // 25% of total score\n  };\n\n  // Feedback templates\n  private readonly FEEDBACK = {\n    excellent: [\n      'Excellent work! Your drawing is spot on!',\n      'Amazing job! Your handwriting is fantastic!',\n      \"Perfect! You've mastered this drawing!\",\n    ],\n    veryGood: [\n      'Very good! Your drawing looks great!',\n      'Impressive work! Keep practicing!',\n      \"Great job! You're getting better each time!\",\n    ],\n    good: [\n      \"Good job! You're making progress!\",\n      'Nice work! Keep practicing!',\n      \"Well done! You're improving!\",\n    ],\n    fair: [\n      'Nice try! Keep practicing!',\n      'Good effort! Try to follow the example more closely!',\n      'Keep going! Practice makes perfect!',\n    ],\n    needsWork: [\n      \"Keep practicing! You'll get better each time!\",\n      'Good start! Try to follow the example more carefully!',\n      \"Don't give up! Every practice helps you improve!\",\n    ],\n  };\n\n  /**\n   * Initialize the score manager\n   */\n  public initialize(): void {\n    // No initialization needed for now\n  }\n\n  /**\n   * Calculate scores for a completed exercise\n   * @param example - The adult's example drawing\n   * @param attempts - The child's attempt drawings (typically 5)\n   * @param constraintBoxes - Optional array of constraint boxes for each attempt\n   * @returns Score result with stars and feedback\n   */\n  public calculateScore(\n    example: DrawingData,\n    attempts: DrawingData[],\n    constraintBoxes?: ConstraintBoxSize[]\n  ): ScoreResult {\n    // We'll focus on the final attempt for the primary score\n    const finalAttempt = attempts[attempts.length - 1];\n\n    if (!finalAttempt) {\n      throw new Error('No attempts provided for scoring');\n    }\n\n    // 1. Calculate accuracy score (path similarity)\n    const accuracyScore = this.calculateAccuracyScore(\n      example,\n      finalAttempt,\n      constraintBoxes?.[attempts.length - 1]\n    );\n\n    // 2. Calculate strokes score (number and length of strokes)\n    const strokesScore = this.calculateStrokesScore(example, finalAttempt);\n\n    // 3. Calculate timing score (rhythm and pace of drawing)\n    const timingScore = this.calculateTimingScore(example, finalAttempt);\n\n    // 4. Calculate overall score\n    const overallScore = Math.round(\n      accuracyScore * this.WEIGHTS.accuracy +\n        strokesScore * this.WEIGHTS.strokes +\n        timingScore * this.WEIGHTS.timing\n    );\n\n    // 5. Convert normalized scores (0-1) to star ratings (1-5)\n    const categories: ScoreCategories = {\n      accuracy: this.normalizedScoreToStars(accuracyScore),\n      strokes: this.normalizedScoreToStars(strokesScore),\n      timing: this.normalizedScoreToStars(timingScore),\n      overall: this.normalizedScoreToStars(overallScore / this.MAX_SCORE),\n    };\n\n    // 6. Generate feedback based on overall score\n    const feedback = this.generateFeedback(overallScore);\n\n    // Create and return the complete score result\n    const scoreResult: ScoreResult = {\n      totalScore: overallScore,\n      categories,\n      feedback,\n      timestamp: Date.now(),\n    };\n\n    // Emit score calculated event\n    this.emit('score-calculated', scoreResult);\n\n    return scoreResult;\n  }\n\n  /**\n   * Calculate accuracy score based on path similarity\n   * @param example - Example drawing\n   * @param attempt - Attempt drawing\n   * @param constraintBox - Optional constraint box size\n   * @returns Normalized score (0-1)\n   */\n  private calculateAccuracyScore(\n    example: DrawingData,\n    attempt: DrawingData,\n    constraintBox?: ConstraintBoxSize\n  ): number {\n    // First, normalize both drawings to same scale for comparison\n    const normalizedExample = this.normalizeDrawing(example);\n    const normalizedAttempt = this.normalizeDrawing(attempt);\n\n    // Prepare for scoring\n    let pathSimilarityScore = 0;\n    let constraintAdherenceScore = 1; // Default to perfect if no constraint box\n\n    // Calculate path similarity using Hausdorff distance\n    pathSimilarityScore = this.calculatePathSimilarity(normalizedExample, normalizedAttempt);\n\n    // If constraint box provided, check if strokes stayed inside\n    if (constraintBox) {\n      constraintAdherenceScore = this.calculateConstraintAdherence(attempt, constraintBox);\n    }\n\n    // Combine path similarity (75%) and constraint adherence (25%)\n    return pathSimilarityScore * 0.75 + constraintAdherenceScore * 0.25;\n  }\n\n  /**\n   * Calculate strokes score based on number and pattern of strokes\n   * @param example - Example drawing\n   * @param attempt - Attempt drawing\n   * @returns Normalized score (0-1)\n   */\n  private calculateStrokesScore(example: DrawingData, attempt: DrawingData): number {\n    // Compare stroke counts\n    const exampleStrokeCount = example.strokes.length;\n    const attemptStrokeCount = attempt.strokes.length;\n\n    // Calculate stroke count similarity (how close the counts are)\n    const countDifference = Math.abs(exampleStrokeCount - attemptStrokeCount);\n    const maxStrokes = Math.max(exampleStrokeCount, attemptStrokeCount);\n    const strokeCountScore = maxStrokes > 0 ? Math.max(0, 1 - countDifference / maxStrokes) : 1;\n\n    // Compare stroke lengths\n    const strokeLengthScore = this.compareStrokeLengths(example, attempt);\n\n    // Combine stroke count (50%) and stroke length (50%) scores\n    return strokeCountScore * 0.5 + strokeLengthScore * 0.5;\n  }\n\n  /**\n   * Calculate timing score based on rhythm and pace\n   * @param example - Example drawing\n   * @param attempt - Attempt drawing\n   * @returns Normalized score (0-1)\n   */\n  private calculateTimingScore(example: DrawingData, attempt: DrawingData): number {\n    // Compare total drawing time\n    const timingRatioScore = this.compareTimingRatio(example, attempt);\n\n    // Compare stroke timing patterns\n    const strokeTimingScore = this.compareStrokeTimingPatterns(example, attempt);\n\n    // Combine total time (40%) and stroke timing (60%) scores\n    return timingRatioScore * 0.4 + strokeTimingScore * 0.6;\n  }\n\n  /**\n   * Calculate path similarity between two drawings\n   * @param example - Normalized example drawing\n   * @param attempt - Normalized attempt drawing\n   * @returns Similarity score (0-1)\n   */\n  private calculatePathSimilarity(example: DrawingData, attempt: DrawingData): number {\n    // If either drawing has no strokes, return 0\n    if (example.strokes.length === 0 || attempt.strokes.length === 0) {\n      return 0;\n    }\n\n    // We'll use a simplified version of the Hausdorff distance\n    // Get all points from both drawings\n    const examplePoints = this.getAllPoints(example);\n    const attemptPoints = this.getAllPoints(attempt);\n\n    if (examplePoints.length === 0 || attemptPoints.length === 0) {\n      return 0;\n    }\n\n    // Calculate average minimum distance from attempt to example\n    let totalDistance = 0;\n\n    for (const attemptPoint of attemptPoints) {\n      // Find minimum distance to any example point\n      let minDistance = Number.MAX_VALUE;\n\n      for (const examplePoint of examplePoints) {\n        const distance = this.calculateDistance(attemptPoint, examplePoint);\n        minDistance = Math.min(minDistance, distance);\n      }\n\n      totalDistance += minDistance;\n    }\n\n    // Average minimum distance\n    const avgDistance = totalDistance / attemptPoints.length;\n\n    // Convert to similarity score (0-1)\n    // The smaller the distance, the higher the similarity\n    // Using an exponential decay function to convert distance to similarity\n    const similarityScore = Math.exp(-avgDistance * 5);\n\n    return similarityScore;\n  }\n\n  /**\n   * Calculate if strokes stay within constraint box\n   * @param attempt - Attempt drawing\n   * @param constraintBox - Constraint box size\n   * @returns Adherence score (0-1)\n   */\n  private calculateConstraintAdherence(\n    attempt: DrawingData,\n    constraintBox: ConstraintBoxSize\n  ): number {\n    // Count points outside constraint box\n    let totalPoints = 0;\n    let pointsOutside = 0;\n\n    // Center of the canvas (assuming constraint box is centered)\n    const centerX = attempt.width / 2;\n    const centerY = attempt.height / 2;\n\n    // Boundaries of constraint box\n    const leftBound = centerX - constraintBox.width / 2;\n    const rightBound = centerX + constraintBox.width / 2;\n    const topBound = centerY - constraintBox.height / 2;\n    const bottomBound = centerY + constraintBox.height / 2;\n\n    // Check each point in each stroke\n    for (const stroke of attempt.strokes) {\n      for (const point of stroke.points) {\n        totalPoints++;\n\n        // Check if point is outside constraint box\n        if (\n          point.x < leftBound ||\n          point.x > rightBound ||\n          point.y < topBound ||\n          point.y > bottomBound\n        ) {\n          pointsOutside++;\n        }\n      }\n    }\n\n    // Calculate adherence score (1 - percentage of points outside)\n    return totalPoints > 0 ? 1 - pointsOutside / totalPoints : 1;\n  }\n\n  /**\n   * Compare the length patterns of strokes\n   * @param example - Example drawing\n   * @param attempt - Attempt drawing\n   * @returns Similarity score (0-1)\n   */\n  private compareStrokeLengths(example: DrawingData, attempt: DrawingData): number {\n    // If either drawing has no strokes, return 0\n    if (example.strokes.length === 0 || attempt.strokes.length === 0) {\n      return 0;\n    }\n\n    // Calculate relative lengths of strokes in each drawing\n    const exampleLengths = this.calculateRelativeStrokeLengths(example);\n    const attemptLengths = this.calculateRelativeStrokeLengths(attempt);\n\n    // Compare stroke length patterns\n    // We'll use the minimum length of the two arrays\n    const minLength = Math.min(exampleLengths.length, attemptLengths.length);\n\n    if (minLength === 0) {\n      return 0;\n    }\n\n    let totalDifference = 0;\n\n    // Compare each stroke's relative length\n    for (let i = 0; i < minLength; i++) {\n      const lengthDifference = Math.abs(exampleLengths[i] - attemptLengths[i]);\n      totalDifference += lengthDifference;\n    }\n\n    // Add penalty for different number of strokes\n    const countDifference = Math.abs(exampleLengths.length - attemptLengths.length);\n    totalDifference += countDifference * 0.1; // Small penalty for each extra/missing stroke\n\n    // Calculate similarity score (0-1)\n    // The smaller the total difference, the higher the similarity\n    const similarityScore = Math.max(0, 1 - totalDifference / minLength);\n\n    return similarityScore;\n  }\n\n  /**\n   * Compare the total drawing time ratio\n   * @param example - Example drawing\n   * @param attempt - Attempt drawing\n   * @returns Similarity score (0-1)\n   */\n  private compareTimingRatio(example: DrawingData, attempt: DrawingData): number {\n    // If either drawing has no total time, return 0.5 (neutral score)\n    if (example.totalTime <= 0 || attempt.totalTime <= 0) {\n      return 0.5;\n    }\n\n    // Calculate ratio of attempt time to example time\n    const timeRatio = attempt.totalTime / example.totalTime;\n\n    // Ideal ratio is 1.0 (same time)\n    // Score decreases as ratio moves away from 1.0 in either direction\n    // Use a bell curve to score the ratio\n    const score = Math.exp(-Math.pow(Math.log(timeRatio), 2));\n\n    return score;\n  }\n\n  /**\n   * Compare timing patterns between strokes\n   * @param example - Example drawing\n   * @param attempt - Attempt drawing\n   * @returns Similarity score (0-1)\n   */\n  private compareStrokeTimingPatterns(example: DrawingData, attempt: DrawingData): number {\n    // If either drawing has too few strokes, return neutral score\n    if (example.strokes.length < 2 || attempt.strokes.length < 2) {\n      return 0.5;\n    }\n\n    // Calculate relative stroke durations\n    const exampleDurations = this.calculateRelativeStrokeDurations(example);\n    const attemptDurations = this.calculateRelativeStrokeDurations(attempt);\n\n    // Compare duration patterns\n    const minLength = Math.min(exampleDurations.length, attemptDurations.length);\n\n    if (minLength < 2) {\n      return 0.5;\n    }\n\n    let totalDifference = 0;\n\n    // Compare each stroke's relative duration\n    for (let i = 0; i < minLength; i++) {\n      const durationDifference = Math.abs(exampleDurations[i] - attemptDurations[i]);\n      totalDifference += durationDifference;\n    }\n\n    // Calculate similarity score (0-1)\n    const similarityScore = Math.max(0, 1 - totalDifference / minLength);\n\n    return similarityScore;\n  }\n\n  /**\n   * Calculate relative stroke lengths as proportions of total length\n   * @param drawing - Drawing data\n   * @returns Array of relative lengths (0-1)\n   */\n  private calculateRelativeStrokeLengths(drawing: DrawingData): number[] {\n    const lengths: number[] = [];\n    let totalLength = 0;\n\n    // Calculate length of each stroke\n    for (const stroke of drawing.strokes) {\n      let strokeLength = 0;\n\n      // Calculate length by summing distances between consecutive points\n      for (let i = 1; i < stroke.points.length; i++) {\n        const p1 = stroke.points[i - 1];\n        const p2 = stroke.points[i];\n        strokeLength += this.calculateDistance(p1, p2);\n      }\n\n      lengths.push(strokeLength);\n      totalLength += strokeLength;\n    }\n\n    // Calculate relative lengths (as proportion of total length)\n    return lengths.map(length => (totalLength > 0 ? length / totalLength : 0));\n  }\n\n  /**\n   * Calculate relative stroke durations as proportions of total time\n   * @param drawing - Drawing data\n   * @returns Array of relative durations (0-1)\n   */\n  private calculateRelativeStrokeDurations(drawing: DrawingData): number[] {\n    const durations: number[] = [];\n    let totalDuration = 0;\n\n    // Calculate duration of each stroke\n    for (const stroke of drawing.strokes) {\n      const duration = stroke.endTime - stroke.startTime;\n      durations.push(duration);\n      totalDuration += duration;\n    }\n\n    // Calculate relative durations (as proportion of total time)\n    return durations.map(duration => (totalDuration > 0 ? duration / totalDuration : 0));\n  }\n\n  /**\n   * Normalize drawing to common scale for comparison\n   * @param drawing - Drawing data to normalize\n   * @returns Normalized drawing data\n   */\n  private normalizeDrawing(drawing: DrawingData): DrawingData {\n    // If drawing is empty, return a copy as is\n    if (drawing.strokes.length === 0) {\n      return {\n        strokes: [],\n        totalTime: drawing.totalTime,\n        width: drawing.width,\n        height: drawing.height,\n        created: drawing.created,\n      };\n    }\n\n    // Find bounding box of the drawing\n    let minX = Number.MAX_VALUE;\n    let maxX = Number.MIN_VALUE;\n    let minY = Number.MAX_VALUE;\n    let maxY = Number.MIN_VALUE;\n\n    for (const stroke of drawing.strokes) {\n      for (const point of stroke.points) {\n        minX = Math.min(minX, point.x);\n        maxX = Math.max(maxX, point.x);\n        minY = Math.min(minY, point.y);\n        maxY = Math.max(maxY, point.y);\n      }\n    }\n\n    // Calculate dimensions and scale factor\n    const width = maxX - minX;\n    const height = maxY - minY;\n    const scale = width > 0 && height > 0 ? Math.min(1 / width, 1 / height) : 1;\n\n    // Create normalized strokes\n    const normalizedStrokes: StrokeData[] = drawing.strokes.map(stroke => {\n      // Create normalized points\n      const normalizedPoints: Point[] = stroke.points.map(point => {\n        return {\n          x: (point.x - minX) * scale,\n          y: (point.y - minY) * scale,\n          timestamp: point.timestamp,\n          pressure: point.pressure,\n        };\n      });\n\n      // Return normalized stroke\n      return {\n        id: stroke.id,\n        points: normalizedPoints,\n        startTime: stroke.startTime,\n        endTime: stroke.endTime,\n        color: stroke.color,\n        width: stroke.width,\n      };\n    });\n\n    // Return normalized drawing\n    return {\n      strokes: normalizedStrokes,\n      totalTime: drawing.totalTime,\n      width: 1, // Normalized to 0-1 range\n      height: height / width, // Maintain aspect ratio\n      created: drawing.created,\n    };\n  }\n\n  /**\n   * Get all points from a drawing as a flat array\n   * @param drawing - Drawing data\n   * @returns Array of all points\n   */\n  private getAllPoints(drawing: DrawingData): Point[] {\n    const points: Point[] = [];\n\n    for (const stroke of drawing.strokes) {\n      points.push(...stroke.points);\n    }\n\n    return points;\n  }\n\n  /**\n   * Calculate Euclidean distance between two points\n   * @param p1 - First point\n   * @param p2 - Second point\n   * @returns Distance between points\n   */\n  private calculateDistance(p1: Point, p2: Point): number {\n    const dx = p2.x - p1.x;\n    const dy = p2.y - p1.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  /**\n   * Convert normalized score (0-1) to star rating (1-5)\n   * @param score - Normalized score (0-1)\n   * @returns Star rating (1-5)\n   */\n  private normalizedScoreToStars(score: number): number {\n    // Ensure score is in range 0-1\n    const normalizedScore = Math.max(0, Math.min(1, score));\n\n    // Convert to star rating (1-5)\n    // Scale of 0-1 to 1-5: (score * 4) + 1\n    return Math.round(normalizedScore * 4 + 1);\n  }\n\n  /**\n   * Generate feedback message based on score\n   * @param score - Score out of 100\n   * @returns Feedback message\n   */\n  private generateFeedback(score: number): string {\n    // Select feedback template based on score\n    let feedbackCategory: keyof typeof this.FEEDBACK;\n\n    if (score >= 90) {\n      feedbackCategory = 'excellent';\n    } else if (score >= 75) {\n      feedbackCategory = 'veryGood';\n    } else if (score >= 60) {\n      feedbackCategory = 'good';\n    } else if (score >= 40) {\n      feedbackCategory = 'fair';\n    } else {\n      feedbackCategory = 'needsWork';\n    }\n\n    // Choose random feedback from selected category\n    const feedbackOptions = this.FEEDBACK[feedbackCategory];\n    const randomIndex = Math.floor(Math.random() * feedbackOptions.length);\n\n    return feedbackOptions[randomIndex];\n  }\n}\n"],"names":["GameManager","storageManager","audioManager","uiManager","drawingManager","scoreManager","state","currentExercise","currentAttempt","isPlaying","isCreatingExercise","MAX_ATTEMPTS","constructor","options","this","handleCreateExercise","bind","handleLoadExercise","handleExerciseSelected","handleSaveExercise","handleCancelExercise","handleDoneButtonClicked","handleAttemptAnimationComplete","handleBackToMenu","handleTryAgain","startNextAttempt","initialize","console","log","setupEventListeners","setupDrawingCanvas","Promise","resolve","on","exercise","data","attemptNumber","starCount","playStarSound","playStrokeSound","canvas","document","querySelector","setCanvas","showWelcomeScreen","showView","playWelcomeSound","reset","parent","parentElement","rect","getBoundingClientRect","ratio","window","devicePixelRatio","width","height","style","enable","exercises","getExercises","length","thumbnails","forEach","thumbnail","getThumbnail","id","updateExerciseList","name","resetHistoryDisplay","showExampleDrawing","adultDrawing","onExampleComplete","off","showScoreScreen","boxSize","calculateConstraintBoxSize","setupAttemptView","playAttemptStartSound","disable","drawingData","getDrawingData","attempts","push","strokes","totalTime","created","Date","now","playAttemptCompleteSound","animateDrawingToHistory","score","calculateScore","saveExerciseResult","playFanfareSound","error","showError","toString","createdAt","highestScore","saveExercise","then","showExerciseSavedConfirmation","setTimeout","catch","cleanupAnimations","scaleFactor","Math","max","startGameWithExercise","DrawingManager","EventEmitter","context","isDrawing","isEnabled","currentStroke","strokeCounter","startTime","endTime","strokeColor","strokeWidth","canvasElement","createElement","classList","add","getContext","Error","addEventListener","handleTouchStart","handleTouchMove","handleTouchEnd","handleMouseDown","handleMouseMove","handleMouseUp","clearRect","pointerEvents","setStrokeColor","color","setStrokeWidth","event","preventDefault","touch","touches","startStroke","clientX","clientY","force","continueStroke","endStroke","x","y","pressure","canvasX","left","canvasY","top","points","timestamp","lineWidth","lineCap","lineJoin","strokeStyle","beginPath","moveTo","emit","lineTo","stroke","getCanvas","ScoreManager","MAX_SCORE","WEIGHTS","accuracy","timing","FEEDBACK","excellent","veryGood","good","fair","needsWork","example","constraintBoxes","finalAttempt","accuracyScore","calculateAccuracyScore","strokesScore","calculateStrokesScore","timingScore","calculateTimingScore","overallScore","round","scoreResult","totalScore","categories","normalizedScoreToStars","overall","feedback","generateFeedback","attempt","constraintBox","normalizedExample","normalizeDrawing","normalizedAttempt","pathSimilarityScore","constraintAdherenceScore","calculatePathSimilarity","calculateConstraintAdherence","exampleStrokeCount","attemptStrokeCount","countDifference","abs","maxStrokes","compareStrokeLengths","compareTimingRatio","compareStrokeTimingPatterns","examplePoints","getAllPoints","attemptPoints","totalDistance","attemptPoint","minDistance","Number","MAX_VALUE","examplePoint","distance","calculateDistance","min","avgDistance","exp","totalPoints","pointsOutside","centerX","centerY","leftBound","rightBound","topBound","bottomBound","point","exampleLengths","calculateRelativeStrokeLengths","attemptLengths","minLength","totalDifference","i","timeRatio","pow","exampleDurations","calculateRelativeStrokeDurations","attemptDurations","drawing","lengths","totalLength","strokeLength","p1","p2","map","durations","totalDuration","duration","minX","maxX","MIN_VALUE","minY","maxY","scale","normalizedPoints","dx","dy","sqrt","normalizedScore","feedbackCategory","feedbackOptions","floor","random"],"mappings":"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"}