{"version":3,"file":"game-z6B-J8CC.js","sources":["../../src/core/GameManager.ts","../../src/core/DrawingManager.ts","../../src/core/ScoreManager.ts"],"sourcesContent":["/**\n * GameManager class\n * Central coordinator for the handwriting exercise game\n */\n\nimport { DrawingManager } from './DrawingManager';\nimport { ScoreManager } from './ScoreManager';\nimport { StorageManager } from '../services/StorageManager';\nimport { AudioManager } from '../services/AudioManager';\nimport { UIManager } from '../services/UIManager';\nimport { Exercise, ConstraintBoxSize, ScoreResult } from '../types/Exercise';\n\n/**\n * GameManager options\n */\ninterface GameManagerOptions {\n  storageManager: StorageManager;\n  audioManager: AudioManager;\n  uiManager: UIManager;\n  drawingManager: DrawingManager;\n  scoreManager: ScoreManager;\n  container: HTMLElement;\n}\n\n/**\n * Game state\n */\ninterface GameState {\n  currentExercise: Exercise | null;\n  currentAttempt: number;\n  isPlaying: boolean;\n  isCreatingExercise: boolean;\n}\n\nexport class GameManager {\n  // Core managers\n  private storageManager: StorageManager;\n  private audioManager: AudioManager;\n  private uiManager: UIManager;\n  private drawingManager: DrawingManager;\n  private scoreManager: ScoreManager;\n\n  // Game state\n  private state: GameState = {\n    currentExercise: null,\n    currentAttempt: 0,\n    isPlaying: false,\n    isCreatingExercise: false,\n  };\n\n  // Constants\n  private readonly MAX_ATTEMPTS = 5;\n\n  /**\n   * Create a new GameManager\n   * @param options - Options for initializing the game manager\n   */\n  constructor(options: GameManagerOptions) {\n    this.storageManager = options.storageManager;\n    this.audioManager = options.audioManager;\n    this.uiManager = options.uiManager;\n    this.drawingManager = options.drawingManager;\n    this.scoreManager = options.scoreManager;\n\n    // Bind methods to maintain context\n    this.handleCreateExercise = this.handleCreateExercise.bind(this);\n    this.handleLoadExercise = this.handleLoadExercise.bind(this);\n    this.handleExerciseSelected = this.handleExerciseSelected.bind(this);\n    this.handleSaveExercise = this.handleSaveExercise.bind(this);\n    this.handleCancelExercise = this.handleCancelExercise.bind(this);\n    this.handleDoneButtonClicked = this.handleDoneButtonClicked.bind(this);\n    this.handleAttemptAnimationComplete = this.handleAttemptAnimationComplete.bind(this);\n    this.handleBackToMenu = this.handleBackToMenu.bind(this);\n    this.handleTryAgain = this.handleTryAgain.bind(this);\n    this.startNextAttempt = this.startNextAttempt.bind(this);\n  }\n\n  /**\n   * Initialize the game manager\n   */\n  public async initialize(): Promise<void> {\n    console.log('Initializing game manager...');\n\n    // Set up event listeners\n    this.setupEventListeners();\n\n    // Set up drawing canvas\n    this.setupDrawingCanvas();\n\n    return Promise.resolve();\n  }\n\n  /**\n   * Setup event listeners\n   */\n  private setupEventListeners(): void {\n    // UI Manager events\n    this.uiManager.on('create-template-clicked', this.handleCreateExercise);\n    this.uiManager.on('load-template-clicked', this.handleLoadExercise);\n    this.uiManager.on('exercise-selected', (exercise: unknown) =>\n      this.handleExerciseSelected(exercise as Exercise)\n    );\n    this.uiManager.on('save-exercise-clicked', (data: unknown) =>\n      this.handleSaveExercise(data as { name: string })\n    );\n    this.uiManager.on('cancel-exercise-clicked', this.handleCancelExercise);\n    this.uiManager.on('done-button-clicked', this.handleDoneButtonClicked);\n    this.uiManager.on('attempt-animation-complete', (attemptNumber: unknown) =>\n      this.handleAttemptAnimationComplete(attemptNumber as number)\n    );\n    this.uiManager.on('back-to-menu-clicked', this.handleBackToMenu);\n    this.uiManager.on('try-again-clicked', this.handleTryAgain);\n    this.uiManager.on('back-clicked', this.handleBackToMenu);\n    this.uiManager.on('star-added', (starCount: unknown) => {\n      this.audioManager.playStarSound(starCount as number);\n    });\n\n    // Drawing Manager events\n    let strokePauseTimer: ReturnType<typeof setTimeout> | null = null;\n    const PAUSE_DELAY = 120; // ms\n    let strokeSoundStarted = false;\n\n    this.drawingManager.on('stroke-started', () => {\n      strokeSoundStarted = false;\n    });\n    this.drawingManager.on('point-added', (point: any) => {\n      if (point && typeof point.y === 'number') {\n        if (!strokeSoundStarted) {\n          this.audioManager.startStrokeSound(point.y);\n          strokeSoundStarted = true;\n        } else {\n          this.audioManager.updateStrokeSound(point.y);\n        }\n        this.audioManager.resumeStrokeSound();\n        if (strokePauseTimer) {\n          clearTimeout(strokePauseTimer);\n        }\n        strokePauseTimer = setTimeout(() => {\n          this.audioManager.pauseStrokeSound();\n        }, PAUSE_DELAY);\n      }\n    });\n    this.drawingManager.on('stroke-completed', () => {\n      if (strokePauseTimer) {\n        clearTimeout(strokePauseTimer);\n      }\n      this.audioManager.pauseStrokeSound();\n      this.audioManager.stopStrokeSound();\n      this.audioManager.playStrokeSound(); // keep the short beep for stroke end\n      strokeSoundStarted = false;\n    });\n  }\n\n  /**\n   * Setup drawing canvas\n   */\n  private setupDrawingCanvas(): void {\n    // Set initial canvas for drawing manager\n    const canvas = document.querySelector('.drawing-canvas') as HTMLCanvasElement;\n    if (canvas) {\n      this.drawingManager.setCanvas(canvas);\n    }\n  }\n\n  /**\n   * Show the welcome screen\n   */\n  public showWelcomeScreen(): void {\n    // Reset state\n    this.state.currentExercise = null;\n    this.state.currentAttempt = 0;\n    this.state.isPlaying = false;\n    this.state.isCreatingExercise = false;\n\n    // Show welcome view\n    this.uiManager.showView('welcome');\n\n    // Play welcome sound\n    // this.audioManager.playWelcomeSound();\n  }\n\n  /**\n   * Handle create exercise button click\n   */\n  private handleCreateExercise(): void {\n    console.log('GameManager: handleCreateExercise - user requested to create new template');\n    // Update state\n    this.state.isCreatingExercise = true;\n\n    // Switch to create exercise view\n    this.uiManager.showView('create-exercise');\n\n    // Reset drawing manager\n    this.drawingManager.reset();\n\n    // Get drawing canvas from the UI\n    const canvas = document.querySelector(\n      '.create-exercise-view .drawing-canvas'\n    ) as HTMLCanvasElement;\n    if (canvas) {\n      // Ensure canvas is sized to its container for correct drawing resolution\n      const parent = canvas.parentElement;\n      if (parent) {\n        const rect = parent.getBoundingClientRect();\n        const ratio = window.devicePixelRatio || 1;\n        canvas.width = rect.width * ratio;\n        canvas.height = rect.height * ratio;\n        canvas.style.width = `${rect.width}px`;\n        canvas.style.height = `${rect.height}px`;\n        this.drawingManager.setCanvas(canvas);\n        this.drawingManager.enable();\n      }\n    }\n  }\n\n  /**\n   * Handle load exercise button click\n   */\n  private handleLoadExercise(): void {\n    console.log('GameManager: handleLoadExercise - fetching saved templates');\n    // Get exercises from storage\n    const exercises = this.storageManager.getExercises();\n    console.log(\n      `GameManager: handleLoadExercise - loaded ${exercises.length} templates`,\n      exercises\n    );\n\n    // Get thumbnails\n    const thumbnails: { [exerciseId: string]: string } = {};\n    exercises.forEach(exercise => {\n      const thumbnail = this.storageManager.getThumbnail(exercise.id);\n      if (thumbnail) {\n        thumbnails[exercise.id] = thumbnail;\n      }\n    });\n\n    // Update exercise list in UI\n    this.uiManager.updateExerciseList(exercises, thumbnails);\n\n    // Show exercise list view\n    this.uiManager.showView('exercise-list');\n  }\n\n  /**\n   * Handle exercise selection\n   * @param exercise - Selected exercise\n   */\n  public handleExerciseSelected(exercise: Exercise): void {\n    console.log(\n      `GameManager: handleExerciseSelected - starting game for template id=${exercise.id} name=\"${exercise.name}\"`\n    );\n    // Update state\n    this.state.currentExercise = exercise;\n    this.state.currentAttempt = 0;\n    this.state.isPlaying = true;\n\n    // Reset history display\n    this.uiManager.resetHistoryDisplay();\n\n    // Switch to attempt view first so the example container is laid out and measurable\n    this.uiManager.showView('attempt');\n\n    // Show example drawing now that the view is visible\n    this.uiManager.showExampleDrawing(exercise.adultDrawing);\n\n    // After animation completes, start the first attempt and remove this listener\n    const onExampleComplete = () => {\n      this.startNextAttempt();\n      this.uiManager.off('example-animation-complete', onExampleComplete);\n    };\n    this.uiManager.on('example-animation-complete', onExampleComplete);\n  }\n\n  /**\n   * Start the next attempt\n   */\n  private startNextAttempt(): void {\n    this.state.currentAttempt++;\n\n    if (this.state.currentAttempt > this.MAX_ATTEMPTS) {\n      this.showScoreScreen();\n      return;\n    }\n\n    // Calculate constraint box size for current attempt\n    const boxSize = this.calculateConstraintBoxSize(this.state.currentAttempt);\n\n    // Set up attempt view\n    this.uiManager.setupAttemptView(this.state.currentAttempt, boxSize);\n\n    // Get drawing canvas from the UI\n    const canvas = document.querySelector('.attempt-view .drawing-canvas') as HTMLCanvasElement;\n    if (canvas) {\n      this.drawingManager.setCanvas(canvas);\n      this.drawingManager.reset();\n      this.drawingManager.enable();\n    }\n\n    // Play attempt start sound\n    this.audioManager.playAttemptStartSound();\n  }\n\n  /**\n   * Handle done button click\n   */\n  private handleDoneButtonClicked(): void {\n    if (!this.state.currentExercise) return;\n\n    // Disable drawing\n    this.drawingManager.disable();\n\n    // Get drawing data\n    const drawingData = this.drawingManager.getDrawingData();\n\n    // Save attempt\n    if (\n      this.state.currentExercise &&\n      this.state.currentAttempt > 0 &&\n      this.state.currentAttempt <= this.MAX_ATTEMPTS\n    ) {\n      // Ensure attempts array has enough slots\n      while (this.state.currentExercise.attempts.length < this.state.currentAttempt) {\n        this.state.currentExercise.attempts.push({\n          strokes: [],\n          totalTime: 0,\n          width: 0,\n          height: 0,\n          created: Date.now(),\n        });\n      }\n\n      // Save current attempt\n      this.state.currentExercise.attempts[this.state.currentAttempt - 1] = drawingData;\n    }\n\n    // Play sound\n    this.audioManager.playAttemptCompleteSound();\n\n    // Animate drawing to history\n    this.uiManager.animateDrawingToHistory(this.state.currentAttempt, drawingData);\n  }\n\n  /**\n   * Handle attempt animation complete\n   * @param attemptNumber - Completed attempt number\n   */\n  private handleAttemptAnimationComplete(attemptNumber: number): void {\n    // Start next attempt or show score\n    if (attemptNumber >= this.MAX_ATTEMPTS) {\n      this.showScoreScreen();\n    } else {\n      this.startNextAttempt();\n    }\n  }\n\n  /**\n   * Show score screen after all attempts\n   */\n  private showScoreScreen(): void {\n    if (!this.state.currentExercise) return;\n\n    // Calculate score\n    const score = this.scoreManager.calculateScore(\n      this.state.currentExercise.adultDrawing,\n      this.state.currentExercise.attempts\n    );\n\n    // Save score to exercise\n    this.saveExerciseResult(this.state.currentExercise, score);\n\n    // Show score screen\n    this.uiManager.showScoreScreen(score);\n\n    // Play fanfare sound\n    this.audioManager.playFanfareSound();\n  }\n\n  /**\n   * Save exercise result\n   * @param exercise - Exercise with attempts\n   * @param score - Score result\n   */\n  private async saveExerciseResult(exercise: Exercise, score: ScoreResult): Promise<void> {\n    try {\n      await this.storageManager.saveExerciseResult(exercise, score);\n    } catch (error) {\n      console.error('Failed to save exercise result:', error);\n      this.uiManager.showError('Failed to save your score');\n    }\n  }\n\n  /**\n   * Handle save exercise button click\n   * @param data - Exercise data with name\n   */\n  private handleSaveExercise(data: { name: string }): void {\n    // Get drawing data\n    const drawingData = this.drawingManager.getDrawingData();\n\n    // Create new exercise\n    const exercise: Exercise = {\n      id: Date.now().toString(),\n      name: data.name,\n      createdAt: new Date(),\n      adultDrawing: drawingData,\n      attempts: [],\n      highestScore: null,\n    };\n\n    // Save exercise\n    this.storageManager\n      .saveExercise(exercise)\n      .then(() => {\n        // Show confirmation\n        this.uiManager.showExerciseSavedConfirmation();\n\n        // Back to welcome screen\n        setTimeout(() => {\n          this.state.isCreatingExercise = false;\n          this.uiManager.showView('welcome');\n        }, 1500);\n      })\n      .catch(error => {\n        console.error('Failed to save exercise:', error);\n        this.uiManager.showError('Failed to save exercise');\n      });\n  }\n\n  /**\n   * Handle cancel exercise button click\n   */\n  private handleCancelExercise(): void {\n    // Update state\n    this.state.isCreatingExercise = false;\n\n    // Return to welcome screen\n    this.uiManager.showView('welcome');\n  }\n\n  /**\n   * Handle back to menu button click\n   */\n  private handleBackToMenu(): void {\n    // Reset state\n    this.state.currentExercise = null;\n    this.state.currentAttempt = 0;\n    this.state.isPlaying = false;\n    this.state.isCreatingExercise = false;\n\n    // Clean up UI\n    this.uiManager.cleanupAnimations();\n    this.uiManager.resetHistoryDisplay();\n\n    // Return to welcome screen\n    this.uiManager.showView('welcome');\n  }\n\n  /**\n   * Handle try again button click\n   */\n  private handleTryAgain(): void {\n    if (!this.state.currentExercise) return;\n\n    // Keep the current exercise, reset attempt\n    this.state.currentAttempt = 0;\n\n    // Clean up UI\n    this.uiManager.resetHistoryDisplay();\n\n    // Switch to attempt view first so the example container is laid out and measurable\n    this.uiManager.showView('attempt');\n\n    // Show example drawing again (location/scale will be reset)\n    this.uiManager.showExampleDrawing(this.state.currentExercise.adultDrawing);\n\n    // After animation, start first attempt\n    this.uiManager.on('example-animation-complete', () => {\n      this.startNextAttempt();\n      // Remove this one-time listener\n      this.uiManager.off('example-animation-complete', this.startNextAttempt);\n    });\n  }\n\n  /**\n   * Calculate constraint box size for a given attempt\n   * @param attemptNumber - Current attempt number (1-5)\n   * @returns Constraint box size\n   */\n  private calculateConstraintBoxSize(attemptNumber: number): ConstraintBoxSize {\n    // Use viewport size for base, matching UIManager\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    const minDimension = Math.min(width, height);\n    const baseSize = minDimension * 0.6; // 60% of smaller dimension\n\n    // For the first attempt, use full base size; shrink only for subsequent attempts\n    const scaleFactor = attemptNumber === 1 ? 1 : Math.max(0.4, 1 - (attemptNumber - 1) * 0.01);\n\n    return {\n      width: baseSize * scaleFactor,\n      height: baseSize * scaleFactor,\n    };\n  }\n\n  /**\n   * Start the game with a specific exercise (template)\n   * @param exercise - Selected exercise\n   */\n  public startGameWithExercise(exercise: Exercise): void {\n    this.handleExerciseSelected(exercise);\n  }\n}\n","/**\n * DrawingManager class\n * Manages drawing operations on the canvas\n */\n\nimport { EventEmitter } from '../utils/EventEmitter';\nimport { StrokeData, DrawingData } from '../types/Exercise';\n\nexport class DrawingManager extends EventEmitter {\n  private canvas: HTMLCanvasElement | null = null;\n  private context: CanvasRenderingContext2D | null = null;\n  private isDrawing: boolean = false;\n  private isEnabled: boolean = false;\n  private currentStroke: StrokeData | null = null;\n  private strokes: StrokeData[] = [];\n  private strokeCounter: number = 0;\n  private startTime: number = 0;\n  private endTime: number = 0;\n  private strokeColor: string = '#000000';\n  private strokeWidth: number = 3;\n\n  /**\n   * Initialize the drawing manager and canvas\n   * @param canvasElement - Optional canvas element to use instead of creating one\n   */\n  public initialize(canvasElement?: HTMLCanvasElement): void {\n    if (canvasElement) {\n      this.canvas = canvasElement;\n    } else {\n      this.canvas = document.createElement('canvas');\n      this.canvas.classList.add('drawing-canvas');\n    }\n\n    this.context = this.canvas.getContext('2d');\n\n    if (!this.context) {\n      throw new Error('Could not get canvas context');\n    }\n\n    this.setupEventListeners();\n    this.reset();\n  }\n\n  /**\n   * Set up event listeners for touch/mouse events\n   */\n  private setupEventListeners(): void {\n    if (!this.canvas) {\n      return;\n    }\n\n    // Touch events for mobile/tablet\n    this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this));\n    this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this));\n    this.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this));\n\n    // Mouse events for desktop\n    this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));\n    this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));\n    this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));\n    this.canvas.addEventListener('mouseleave', this.handleMouseUp.bind(this));\n  }\n\n  /**\n   * Reset the drawing manager\n   */\n  public reset(): void {\n    this.strokes = [];\n    this.strokeCounter = 0;\n    this.startTime = 0;\n    this.endTime = 0;\n    this.isDrawing = false;\n    this.currentStroke = null;\n\n    if (this.canvas && this.context) {\n      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    }\n  }\n\n  /**\n   * Enable drawing\n   */\n  public enable(): void {\n    this.isEnabled = true;\n    if (this.canvas) {\n      this.canvas.style.pointerEvents = 'auto';\n    }\n  }\n\n  /**\n   * Disable drawing\n   */\n  public disable(): void {\n    this.isEnabled = false;\n    this.isDrawing = false;\n    this.currentStroke = null;\n    if (this.canvas) {\n      this.canvas.style.pointerEvents = 'none';\n    }\n  }\n\n  /**\n   * Set stroke color\n   * @param color - CSS color string\n   */\n  public setStrokeColor(color: string): void {\n    this.strokeColor = color;\n  }\n\n  /**\n   * Set stroke width\n   * @param width - Width in pixels\n   */\n  public setStrokeWidth(width: number): void {\n    this.strokeWidth = width;\n  }\n\n  /**\n   * Handle touch start event\n   * @param event - Touch event\n   */\n  private handleTouchStart(event: TouchEvent): void {\n    if (!this.isEnabled) return;\n\n    event.preventDefault();\n\n    const touch = event.touches[0];\n    this.startStroke(touch.clientX, touch.clientY, touch.force);\n  }\n\n  /**\n   * Handle touch move event\n   * @param event - Touch event\n   */\n  private handleTouchMove(event: TouchEvent): void {\n    if (!this.isEnabled || !this.isDrawing) return;\n\n    event.preventDefault();\n\n    const touch = event.touches[0];\n    this.continueStroke(touch.clientX, touch.clientY, touch.force);\n  }\n\n  /**\n   * Handle touch end event\n   * @param event - Touch event\n   */\n  private handleTouchEnd(event: TouchEvent): void {\n    if (!this.isEnabled) return;\n\n    event.preventDefault();\n    this.endStroke();\n  }\n\n  /**\n   * Handle mouse down event\n   * @param event - Mouse event\n   */\n  private handleMouseDown(event: MouseEvent): void {\n    if (!this.isEnabled) return;\n\n    event.preventDefault();\n    this.startStroke(event.clientX, event.clientY);\n  }\n\n  /**\n   * Handle mouse move event\n   * @param event - Mouse event\n   */\n  private handleMouseMove(event: MouseEvent): void {\n    if (!this.isEnabled || !this.isDrawing) return;\n\n    event.preventDefault();\n    this.continueStroke(event.clientX, event.clientY);\n  }\n\n  /**\n   * Handle mouse up event\n   * @param event - Mouse event\n   */\n  private handleMouseUp(event: MouseEvent): void {\n    if (!this.isEnabled) return;\n\n    event.preventDefault();\n    this.endStroke();\n  }\n\n  /**\n   * Start a new stroke\n   * @param x - X coordinate\n   * @param y - Y coordinate\n   * @param pressure - Optional pressure value\n   */\n  private startStroke(x: number, y: number, pressure: number = 1): void {\n    if (!this.canvas || !this.context) return;\n\n    // Get canvas-relative coordinates\n    const rect = this.canvas.getBoundingClientRect();\n    const pixelRatio = this.canvas.width / rect.width;\n    const canvasX = (x - rect.left) * pixelRatio;\n    const canvasY = (y - rect.top) * pixelRatio;\n\n    const now = Date.now();\n\n    // If this is the first stroke, record start time\n    if (this.strokes.length === 0) {\n      this.startTime = now;\n    }\n\n    this.isDrawing = true;\n\n    // Create a new stroke\n    this.currentStroke = {\n      id: this.strokeCounter++,\n      points: [\n        {\n          x: canvasX,\n          y: canvasY,\n          timestamp: now,\n          pressure: pressure,\n        },\n      ],\n      startTime: now,\n      endTime: now,\n      color: this.strokeColor,\n      width: this.strokeWidth,\n    };\n\n    // Setup drawing style\n    this.context.lineWidth = 3;\n    this.context.lineCap = 'round';\n    this.context.lineJoin = 'round';\n    this.context.strokeStyle = this.strokeColor;\n    this.context.beginPath();\n    this.context.moveTo(canvasX, canvasY);\n\n    // Emit stroke start event\n    this.emit('stroke-started', this.currentStroke);\n  }\n\n  /**\n   * Continue the current stroke\n   * @param x - X coordinate\n   * @param y - Y coordinate\n   * @param pressure - Optional pressure value\n   */\n  private continueStroke(x: number, y: number, pressure: number = 1): void {\n    if (!this.canvas || !this.context || !this.currentStroke) return;\n\n    // Get canvas-relative coordinates\n    const rect = this.canvas.getBoundingClientRect();\n    const pixelRatio = this.canvas.width / rect.width;\n    const canvasX = (x - rect.left) * pixelRatio;\n    const canvasY = (y - rect.top) * pixelRatio;\n\n    const now = Date.now();\n\n    // Add point to the current stroke\n    this.currentStroke.points.push({\n      x: canvasX,\n      y: canvasY,\n      timestamp: now,\n      pressure: pressure,\n    });\n\n    // Draw line to the new point\n    this.context.lineTo(canvasX, canvasY);\n    this.context.stroke();\n    this.context.beginPath();\n    this.context.moveTo(canvasX, canvasY);\n\n    // Emit point added event\n    this.emit('point-added', {\n      x: canvasX,\n      y: canvasY,\n      timestamp: now,\n      pressure,\n    });\n  }\n\n  /**\n   * End the current stroke\n   */\n  private endStroke(): void {\n    if (!this.currentStroke) return;\n\n    const now = Date.now();\n    this.currentStroke.endTime = now;\n    this.endTime = now;\n\n    // Add the completed stroke to the strokes array\n    this.strokes.push(this.currentStroke);\n\n    this.isDrawing = false;\n    this.currentStroke = null;\n\n    // Emit stroke completed event\n    this.emit('stroke-completed', this.strokes[this.strokes.length - 1]);\n  }\n\n  /**\n   * Set the canvas element for drawing\n   * @param canvas - Canvas element\n   */\n  public setCanvas(canvas: HTMLCanvasElement): void {\n    this.canvas = canvas;\n    this.context = canvas.getContext('2d');\n    this.setupEventListeners();\n  }\n\n  /**\n   * Get the current canvas element\n   */\n  public getCanvas(): HTMLCanvasElement | null {\n    return this.canvas;\n  }\n\n  /**\n   * Get drawing data\n   */\n  public getDrawingData(): DrawingData {\n    return {\n      strokes: [...this.strokes],\n      totalTime: this.endTime - this.startTime,\n      width: this.canvas?.width || 0,\n      height: this.canvas?.height || 0,\n      created: Date.now(),\n    };\n  }\n}\n","/**\n * ScoreManager class\n * Handles the scoring system for comparing drawings\n */\n\nimport { EventEmitter } from '../utils/EventEmitter';\nimport {\n  DrawingData,\n  StrokeData,\n  Point,\n  ScoreResult,\n  ScoreCategories,\n  ConstraintBoxSize,\n} from '../types/Exercise';\n\nexport class ScoreManager extends EventEmitter {\n  // Constants for scoring\n  private readonly MAX_SCORE = 100;\n\n  // Weights for different scoring categories\n  private readonly WEIGHTS = {\n    accuracy: 0.5, // 50% of total score\n    strokes: 0.25, // 25% of total score\n    timing: 0.25, // 25% of total score\n  };\n\n  // Feedback templates\n  private readonly FEEDBACK = {\n    excellent: [\n      'Excellent work! Your drawing is spot on!',\n      'Amazing job! Your handwriting is fantastic!',\n      \"Perfect! You've mastered this drawing!\",\n    ],\n    veryGood: [\n      'Very good! Your drawing looks great!',\n      'Impressive work! Keep practicing!',\n      \"Great job! You're getting better each time!\",\n    ],\n    good: [\n      \"Good job! You're making progress!\",\n      'Nice work! Keep practicing!',\n      \"Well done! You're improving!\",\n    ],\n    fair: [\n      'Nice try! Keep practicing!',\n      'Good effort! Try to follow the example more closely!',\n      'Keep going! Practice makes perfect!',\n    ],\n    needsWork: [\n      \"Keep practicing! You'll get better each time!\",\n      'Good start! Try to follow the example more carefully!',\n      \"Don't give up! Every practice helps you improve!\",\n    ],\n  };\n\n  /**\n   * Initialize the score manager\n   */\n  public initialize(): void {\n    // No initialization needed for now\n  }\n\n  /**\n   * Calculate scores for a completed exercise\n   * @param example - The adult's example drawing\n   * @param attempts - The child's attempt drawings (typically 5)\n   * @param constraintBoxes - Optional array of constraint boxes for each attempt\n   * @returns Score result with stars and feedback\n   */\n  public calculateScore(\n    example: DrawingData,\n    attempts: DrawingData[],\n    constraintBoxes?: ConstraintBoxSize[]\n  ): ScoreResult {\n    // We'll focus on the final attempt for the primary score\n    const finalAttempt = attempts[attempts.length - 1];\n\n    if (!finalAttempt) {\n      throw new Error('No attempts provided for scoring');\n    }\n\n    // 1. Calculate accuracy score (path similarity)\n    const accuracyScore = this.calculateAccuracyScore(\n      example,\n      finalAttempt,\n      constraintBoxes?.[attempts.length - 1]\n    );\n    console.log('accuracyScore', accuracyScore);\n\n    // 2. Calculate strokes score (number and length of strokes)\n    const strokesScore = this.calculateStrokesScore(example, finalAttempt);\n    console.log('strokesScore', strokesScore);\n\n    // 3. Calculate timing score (rhythm and pace of drawing)\n    const timingScore = this.calculateTimingScore(example, finalAttempt);\n    console.log('timingScore', timingScore);\n\n    // 4. Calculate overall score\n    const overallScore = Math.round(\n      (accuracyScore * this.WEIGHTS.accuracy +\n        strokesScore * this.WEIGHTS.strokes +\n        timingScore * this.WEIGHTS.timing) *\n        this.MAX_SCORE\n    );\n    console.log('overallScore', overallScore);\n\n    // 5. Convert normalized scores (0-1) to star ratings (1-5)\n    const categories: ScoreCategories = {\n      accuracy: this.normalizedScoreToStars(accuracyScore),\n      strokes: this.normalizedScoreToStars(strokesScore),\n      timing: this.normalizedScoreToStars(timingScore),\n      overall: this.normalizedScoreToStars(overallScore / this.MAX_SCORE),\n    };\n    console.log('categories', categories);\n\n    // 6. Generate feedback based on overall score\n    const feedback = this.generateFeedback(overallScore);\n    console.log('feedback', feedback);\n\n    // Create and return the complete score result\n    const scoreResult: ScoreResult = {\n      totalScore: overallScore,\n      categories,\n      feedback,\n      timestamp: Date.now(),\n    };\n    console.log('scoreResult', scoreResult);\n\n    // Emit score calculated event\n    this.emit('score-calculated', scoreResult);\n\n    return scoreResult;\n  }\n\n  /**\n   * Calculate accuracy score based on path similarity\n   * @param example - Example drawing\n   * @param attempt - Attempt drawing\n   * @param constraintBox - Optional constraint box size\n   * @returns Normalized score (0-1)\n   */\n  private calculateAccuracyScore(\n    example: DrawingData,\n    attempt: DrawingData,\n    constraintBox?: ConstraintBoxSize\n  ): number {\n    // First, normalize both drawings to same scale for comparison\n    const normalizedExample = this.normalizeDrawing(example);\n    const normalizedAttempt = this.normalizeDrawing(attempt);\n\n    // Prepare for scoring\n    let pathSimilarityScore = 0;\n    let constraintAdherenceScore = 1; // Default to perfect if no constraint box\n\n    // Calculate path similarity using Hausdorff distance\n    pathSimilarityScore = this.calculatePathSimilarity(normalizedExample, normalizedAttempt);\n\n    // If constraint box provided, check if strokes stayed inside\n    if (constraintBox) {\n      constraintAdherenceScore = this.calculateConstraintAdherence(attempt, constraintBox);\n    }\n\n    // Combine path similarity (75%) and constraint adherence (25%)\n    return pathSimilarityScore * 0.75 + constraintAdherenceScore * 0.25;\n  }\n\n  /**\n   * Calculate strokes score based on number and pattern of strokes\n   * @param example - Example drawing\n   * @param attempt - Attempt drawing\n   * @returns Normalized score (0-1)\n   */\n  private calculateStrokesScore(example: DrawingData, attempt: DrawingData): number {\n    // Compare stroke counts\n    const exampleStrokeCount = example.strokes.length;\n    const attemptStrokeCount = attempt.strokes.length;\n\n    // Calculate stroke count similarity (how close the counts are)\n    const countDifference = Math.abs(exampleStrokeCount - attemptStrokeCount);\n    const maxStrokes = Math.max(exampleStrokeCount, attemptStrokeCount);\n    const strokeCountScore = maxStrokes > 0 ? Math.max(0, 1 - countDifference / maxStrokes) : 1;\n\n    // Compare stroke lengths\n    const strokeLengthScore = this.compareStrokeLengths(example, attempt);\n\n    // Combine stroke count (50%) and stroke length (50%) scores\n    return strokeCountScore * 0.5 + strokeLengthScore * 0.5;\n  }\n\n  /**\n   * Calculate timing score based on rhythm and pace\n   * @param example - Example drawing\n   * @param attempt - Attempt drawing\n   * @returns Normalized score (0-1)\n   */\n  private calculateTimingScore(example: DrawingData, attempt: DrawingData): number {\n    // Compare total drawing time\n    const timingRatioScore = this.compareTimingRatio(example, attempt);\n\n    // Compare stroke timing patterns\n    const strokeTimingScore = this.compareStrokeTimingPatterns(example, attempt);\n\n    // Combine total time (40%) and stroke timing (60%) scores\n    return timingRatioScore * 0.4 + strokeTimingScore * 0.6;\n  }\n\n  /**\n   * Calculate path similarity between two drawings\n   * @param example - Normalized example drawing\n   * @param attempt - Normalized attempt drawing\n   * @returns Similarity score (0-1)\n   */\n  private calculatePathSimilarity(example: DrawingData, attempt: DrawingData): number {\n    // If either drawing has no strokes, return 0\n    if (example.strokes.length === 0 || attempt.strokes.length === 0) {\n      return 0;\n    }\n\n    // We'll use a simplified version of the Hausdorff distance\n    // Get all points from both drawings\n    const examplePoints = this.getAllPoints(example);\n    const attemptPoints = this.getAllPoints(attempt);\n\n    if (examplePoints.length === 0 || attemptPoints.length === 0) {\n      return 0;\n    }\n\n    // Calculate average minimum distance from attempt to example\n    let totalDistance = 0;\n\n    for (const attemptPoint of attemptPoints) {\n      // Find minimum distance to any example point\n      let minDistance = Number.MAX_VALUE;\n\n      for (const examplePoint of examplePoints) {\n        const distance = this.calculateDistance(attemptPoint, examplePoint);\n        minDistance = Math.min(minDistance, distance);\n      }\n\n      totalDistance += minDistance;\n    }\n\n    // Average minimum distance\n    const avgDistance = totalDistance / attemptPoints.length;\n\n    // Convert to similarity score (0-1)\n    // The smaller the distance, the higher the similarity\n    // Using an exponential decay function to convert distance to similarity\n    const similarityScore = Math.exp(-avgDistance * 5);\n\n    return similarityScore;\n  }\n\n  /**\n   * Calculate if strokes stay within constraint box\n   * @param attempt - Attempt drawing\n   * @param constraintBox - Constraint box size\n   * @returns Adherence score (0-1)\n   */\n  private calculateConstraintAdherence(\n    attempt: DrawingData,\n    constraintBox: ConstraintBoxSize\n  ): number {\n    // Count points outside constraint box\n    let totalPoints = 0;\n    let pointsOutside = 0;\n\n    // Center of the canvas (assuming constraint box is centered)\n    const centerX = attempt.width / 2;\n    const centerY = attempt.height / 2;\n\n    // Boundaries of constraint box\n    const leftBound = centerX - constraintBox.width / 2;\n    const rightBound = centerX + constraintBox.width / 2;\n    const topBound = centerY - constraintBox.height / 2;\n    const bottomBound = centerY + constraintBox.height / 2;\n\n    // Check each point in each stroke\n    for (const stroke of attempt.strokes) {\n      for (const point of stroke.points) {\n        totalPoints++;\n\n        // Check if point is outside constraint box\n        if (\n          point.x < leftBound ||\n          point.x > rightBound ||\n          point.y < topBound ||\n          point.y > bottomBound\n        ) {\n          pointsOutside++;\n        }\n      }\n    }\n\n    // Calculate adherence score (1 - percentage of points outside)\n    return totalPoints > 0 ? 1 - pointsOutside / totalPoints : 1;\n  }\n\n  /**\n   * Compare the length patterns of strokes\n   * @param example - Example drawing\n   * @param attempt - Attempt drawing\n   * @returns Similarity score (0-1)\n   */\n  private compareStrokeLengths(example: DrawingData, attempt: DrawingData): number {\n    // If either drawing has no strokes, return 0\n    if (example.strokes.length === 0 || attempt.strokes.length === 0) {\n      return 0;\n    }\n\n    // Calculate relative lengths of strokes in each drawing\n    const exampleLengths = this.calculateRelativeStrokeLengths(example);\n    const attemptLengths = this.calculateRelativeStrokeLengths(attempt);\n\n    // Compare stroke length patterns\n    // We'll use the minimum length of the two arrays\n    const minLength = Math.min(exampleLengths.length, attemptLengths.length);\n\n    if (minLength === 0) {\n      return 0;\n    }\n\n    let totalDifference = 0;\n\n    // Compare each stroke's relative length\n    for (let i = 0; i < minLength; i++) {\n      const lengthDifference = Math.abs(exampleLengths[i] - attemptLengths[i]);\n      totalDifference += lengthDifference;\n    }\n\n    // Add penalty for different number of strokes\n    const countDifference = Math.abs(exampleLengths.length - attemptLengths.length);\n    totalDifference += countDifference * 0.1; // Small penalty for each extra/missing stroke\n\n    // Calculate similarity score (0-1)\n    // The smaller the total difference, the higher the similarity\n    const similarityScore = Math.max(0, 1 - totalDifference / minLength);\n\n    return similarityScore;\n  }\n\n  /**\n   * Compare the total drawing time ratio\n   * @param example - Example drawing\n   * @param attempt - Attempt drawing\n   * @returns Similarity score (0-1)\n   */\n  private compareTimingRatio(example: DrawingData, attempt: DrawingData): number {\n    // If either drawing has no total time, return 0.5 (neutral score)\n    if (example.totalTime <= 0 || attempt.totalTime <= 0) {\n      return 0.5;\n    }\n\n    // Calculate ratio of attempt time to example time\n    const timeRatio = attempt.totalTime / example.totalTime;\n\n    // Ideal ratio is 1.0 (same time)\n    // Score decreases as ratio moves away from 1.0 in either direction\n    // Use a bell curve to score the ratio\n    const score = Math.exp(-Math.pow(Math.log(timeRatio), 2));\n\n    return score;\n  }\n\n  /**\n   * Compare timing patterns between strokes\n   * @param example - Example drawing\n   * @param attempt - Attempt drawing\n   * @returns Similarity score (0-1)\n   */\n  private compareStrokeTimingPatterns(example: DrawingData, attempt: DrawingData): number {\n    // If either drawing has too few strokes, return neutral score\n    if (example.strokes.length < 2 || attempt.strokes.length < 2) {\n      return 0.5;\n    }\n\n    // Calculate relative stroke durations\n    const exampleDurations = this.calculateRelativeStrokeDurations(example);\n    const attemptDurations = this.calculateRelativeStrokeDurations(attempt);\n\n    // Compare duration patterns\n    const minLength = Math.min(exampleDurations.length, attemptDurations.length);\n\n    if (minLength < 2) {\n      return 0.5;\n    }\n\n    let totalDifference = 0;\n\n    // Compare each stroke's relative duration\n    for (let i = 0; i < minLength; i++) {\n      const durationDifference = Math.abs(exampleDurations[i] - attemptDurations[i]);\n      totalDifference += durationDifference;\n    }\n\n    // Calculate similarity score (0-1)\n    const similarityScore = Math.max(0, 1 - totalDifference / minLength);\n\n    return similarityScore;\n  }\n\n  /**\n   * Calculate relative stroke lengths as proportions of total length\n   * @param drawing - Drawing data\n   * @returns Array of relative lengths (0-1)\n   */\n  private calculateRelativeStrokeLengths(drawing: DrawingData): number[] {\n    const lengths: number[] = [];\n    let totalLength = 0;\n\n    // Calculate length of each stroke\n    for (const stroke of drawing.strokes) {\n      let strokeLength = 0;\n\n      // Calculate length by summing distances between consecutive points\n      for (let i = 1; i < stroke.points.length; i++) {\n        const p1 = stroke.points[i - 1];\n        const p2 = stroke.points[i];\n        strokeLength += this.calculateDistance(p1, p2);\n      }\n\n      lengths.push(strokeLength);\n      totalLength += strokeLength;\n    }\n\n    // Calculate relative lengths (as proportion of total length)\n    return lengths.map(length => (totalLength > 0 ? length / totalLength : 0));\n  }\n\n  /**\n   * Calculate relative stroke durations as proportions of total time\n   * @param drawing - Drawing data\n   * @returns Array of relative durations (0-1)\n   */\n  private calculateRelativeStrokeDurations(drawing: DrawingData): number[] {\n    const durations: number[] = [];\n    let totalDuration = 0;\n\n    // Calculate duration of each stroke\n    for (const stroke of drawing.strokes) {\n      const duration = stroke.endTime - stroke.startTime;\n      durations.push(duration);\n      totalDuration += duration;\n    }\n\n    // Calculate relative durations (as proportion of total time)\n    return durations.map(duration => (totalDuration > 0 ? duration / totalDuration : 0));\n  }\n\n  /**\n   * Normalize drawing to common scale for comparison\n   * @param drawing - Drawing data to normalize\n   * @returns Normalized drawing data\n   */\n  private normalizeDrawing(drawing: DrawingData): DrawingData {\n    // If drawing is empty, return a copy as is\n    if (drawing.strokes.length === 0) {\n      return {\n        strokes: [],\n        totalTime: drawing.totalTime,\n        width: drawing.width,\n        height: drawing.height,\n        created: drawing.created,\n      };\n    }\n\n    // Find bounding box of the drawing\n    let minX = Number.MAX_VALUE;\n    let maxX = Number.MIN_VALUE;\n    let minY = Number.MAX_VALUE;\n    let maxY = Number.MIN_VALUE;\n\n    for (const stroke of drawing.strokes) {\n      for (const point of stroke.points) {\n        minX = Math.min(minX, point.x);\n        maxX = Math.max(maxX, point.x);\n        minY = Math.min(minY, point.y);\n        maxY = Math.max(maxY, point.y);\n      }\n    }\n\n    // Calculate dimensions and scale factor\n    const width = maxX - minX;\n    const height = maxY - minY;\n    const scale = width > 0 && height > 0 ? Math.min(1 / width, 1 / height) : 1;\n\n    // Create normalized strokes\n    const normalizedStrokes: StrokeData[] = drawing.strokes.map(stroke => {\n      // Create normalized points\n      const normalizedPoints: Point[] = stroke.points.map(point => {\n        return {\n          x: (point.x - minX) * scale,\n          y: (point.y - minY) * scale,\n          timestamp: point.timestamp,\n          pressure: point.pressure,\n        };\n      });\n\n      // Return normalized stroke\n      return {\n        id: stroke.id,\n        points: normalizedPoints,\n        startTime: stroke.startTime,\n        endTime: stroke.endTime,\n        color: stroke.color,\n        width: stroke.width,\n      };\n    });\n\n    // Return normalized drawing\n    return {\n      strokes: normalizedStrokes,\n      totalTime: drawing.totalTime,\n      width: 1, // Normalized to 0-1 range\n      height: height / width, // Maintain aspect ratio\n      created: drawing.created,\n    };\n  }\n\n  /**\n   * Get all points from a drawing as a flat array\n   * @param drawing - Drawing data\n   * @returns Array of all points\n   */\n  private getAllPoints(drawing: DrawingData): Point[] {\n    const points: Point[] = [];\n\n    for (const stroke of drawing.strokes) {\n      points.push(...stroke.points);\n    }\n\n    return points;\n  }\n\n  /**\n   * Calculate Euclidean distance between two points\n   * @param p1 - First point\n   * @param p2 - Second point\n   * @returns Distance between points\n   */\n  private calculateDistance(p1: Point, p2: Point): number {\n    const dx = p2.x - p1.x;\n    const dy = p2.y - p1.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  /**\n   * Convert normalized score (0-1) to star rating (1-5)\n   * @param score - Normalized score (0-1)\n   * @returns Star rating (1-5)\n   */\n  private normalizedScoreToStars(score: number): number {\n    // Ensure score is in range 0-1\n    const normalizedScore = Math.max(0, Math.min(1, score));\n\n    // Convert to star rating (1-5)\n    // Scale of 0-1 to 1-5: (score * 4) + 1\n    return Math.round(normalizedScore * 4 + 1);\n  }\n\n  /**\n   * Generate feedback message based on score\n   * @param score - Score out of 100\n   * @returns Feedback message\n   */\n  private generateFeedback(score: number): string {\n    // Select feedback template based on score\n    let feedbackCategory: keyof typeof this.FEEDBACK;\n\n    if (score >= 90) {\n      feedbackCategory = 'excellent';\n    } else if (score >= 75) {\n      feedbackCategory = 'veryGood';\n    } else if (score >= 60) {\n      feedbackCategory = 'good';\n    } else if (score >= 40) {\n      feedbackCategory = 'fair';\n    } else {\n      feedbackCategory = 'needsWork';\n    }\n\n    // Choose random feedback from selected category\n    const feedbackOptions = this.FEEDBACK[feedbackCategory];\n    const randomIndex = Math.floor(Math.random() * feedbackOptions.length);\n\n    return feedbackOptions[randomIndex];\n  }\n}\n"],"names":["GameManager","storageManager","audioManager","uiManager","drawingManager","scoreManager","state","currentExercise","currentAttempt","isPlaying","isCreatingExercise","MAX_ATTEMPTS","constructor","options","this","handleCreateExercise","bind","handleLoadExercise","handleExerciseSelected","handleSaveExercise","handleCancelExercise","handleDoneButtonClicked","handleAttemptAnimationComplete","handleBackToMenu","handleTryAgain","startNextAttempt","initialize","console","log","setupEventListeners","setupDrawingCanvas","Promise","resolve","on","exercise","data","attemptNumber","starCount","playStarSound","strokePauseTimer","strokeSoundStarted","point","y","updateStrokeSound","startStrokeSound","resumeStrokeSound","clearTimeout","setTimeout","pauseStrokeSound","stopStrokeSound","playStrokeSound","canvas","document","querySelector","setCanvas","showWelcomeScreen","showView","reset","parent","parentElement","rect","getBoundingClientRect","ratio","window","devicePixelRatio","width","height","style","enable","exercises","getExercises","length","thumbnails","forEach","thumbnail","getThumbnail","id","updateExerciseList","name","resetHistoryDisplay","showExampleDrawing","adultDrawing","onExampleComplete","off","showScoreScreen","boxSize","calculateConstraintBoxSize","setupAttemptView","playAttemptStartSound","disable","drawingData","getDrawingData","attempts","push","strokes","totalTime","created","Date","now","playAttemptCompleteSound","animateDrawingToHistory","score","calculateScore","saveExerciseResult","playFanfareSound","error","showError","toString","createdAt","highestScore","saveExercise","then","showExerciseSavedConfirmation","catch","cleanupAnimations","innerWidth","innerHeight","baseSize","Math","min","scaleFactor","max","startGameWithExercise","DrawingManager","EventEmitter","context","isDrawing","isEnabled","currentStroke","strokeCounter","startTime","endTime","strokeColor","strokeWidth","canvasElement","createElement","classList","add","getContext","Error","addEventListener","handleTouchStart","handleTouchMove","handleTouchEnd","handleMouseDown","handleMouseMove","handleMouseUp","clearRect","pointerEvents","setStrokeColor","color","setStrokeWidth","event","preventDefault","touch","touches","startStroke","clientX","clientY","force","continueStroke","endStroke","x","pressure","pixelRatio","canvasX","left","canvasY","top","points","timestamp","lineWidth","lineCap","lineJoin","strokeStyle","beginPath","moveTo","emit","lineTo","stroke","getCanvas","ScoreManager","MAX_SCORE","WEIGHTS","accuracy","timing","FEEDBACK","excellent","veryGood","good","fair","needsWork","example","constraintBoxes","finalAttempt","accuracyScore","calculateAccuracyScore","strokesScore","calculateStrokesScore","timingScore","calculateTimingScore","overallScore","round","categories","normalizedScoreToStars","overall","feedback","generateFeedback","scoreResult","totalScore","attempt","constraintBox","normalizedExample","normalizeDrawing","normalizedAttempt","pathSimilarityScore","constraintAdherenceScore","calculatePathSimilarity","calculateConstraintAdherence","exampleStrokeCount","attemptStrokeCount","countDifference","abs","maxStrokes","compareStrokeLengths","compareTimingRatio","compareStrokeTimingPatterns","examplePoints","getAllPoints","attemptPoints","totalDistance","attemptPoint","minDistance","Number","MAX_VALUE","examplePoint","distance","calculateDistance","avgDistance","exp","totalPoints","pointsOutside","centerX","centerY","leftBound","rightBound","topBound","bottomBound","exampleLengths","calculateRelativeStrokeLengths","attemptLengths","minLength","totalDifference","i","timeRatio","pow","exampleDurations","calculateRelativeStrokeDurations","attemptDurations","drawing","lengths","totalLength","strokeLength","p1","p2","map","durations","totalDuration","duration","minX","maxX","MIN_VALUE","minY","maxY","scale","normalizedPoints","dx","dy","sqrt","normalizedScore","feedbackCategory","feedbackOptions","floor","random"],"mappings":"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"}