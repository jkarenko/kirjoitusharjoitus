{"version":3,"file":"vendor-Agrq7mF9.js","sources":["../../src/utils/EventEmitter.ts","../../src/services/StorageManager.ts","../../src/services/AudioManager.ts"],"sourcesContent":["/**\n * EventEmitter\n * A simple event system for component communication\n */\n\n// Define event mapping interface for type safety\nexport interface EventMap {\n  [event: string]: unknown[];\n}\n\n// Type for event callback based on event name and arguments\nexport type EventCallback<T extends EventMap, K extends keyof T> = (...args: T[K]) => void;\n\nexport class EventEmitter<T extends EventMap = Record<string, unknown[]>> {\n  private events: Map<keyof T, Array<EventCallback<T, keyof T>>> = new Map();\n\n  /**\n   * Register an event listener\n   * @param event - Event name\n   * @param callback - Callback function to execute when event is emitted\n   */\n  public on<K extends keyof T>(event: K, callback: EventCallback<T, K>): void {\n    if (!this.events.has(event)) {\n      this.events.set(event, []);\n    }\n    \n    const callbacks = this.events.get(event);\n    if (callbacks) {\n      callbacks.push(callback as EventCallback<T, keyof T>);\n    }\n  }\n\n  /**\n   * Remove an event listener\n   * @param event - Event name\n   * @param callback - Callback function to remove\n   */\n  public off<K extends keyof T>(event: K, callback: EventCallback<T, K>): void {\n    if (!this.events.has(event)) {\n      return;\n    }\n    \n    const callbacks = this.events.get(event);\n    if (callbacks) {\n      const index = callbacks.indexOf(callback as EventCallback<T, keyof T>);\n      if (index !== -1) {\n        callbacks.splice(index, 1);\n        \n        // Clean up empty arrays\n        if (callbacks.length === 0) {\n          this.events.delete(event);\n        }\n      }\n    }\n  }\n\n  /**\n   * Emit an event with optional arguments\n   * @param event - Event name\n   * @param args - Arguments to pass to event listeners\n   */\n  public emit<K extends keyof T>(event: K, ...args: T[K]): void {\n    if (!this.events.has(event)) {\n      return;\n    }\n    \n    const callbacks = this.events.get(event);\n    if (callbacks) {\n      // Create a copy to avoid issues if callbacks are added/removed during emission\n      const callbacksCopy = [...callbacks];\n      callbacksCopy.forEach(callback => {\n        try {\n          callback(...args);\n        } catch (error) {\n          console.error(`Error in event handler for ${String(event)}:`, error);\n        }\n      });\n    }\n  }\n\n  /**\n   * Remove all event listeners\n   */\n  public removeAllListeners(): void {\n    this.events.clear();\n  }\n}\n\n","/**\n * StorageManager class\n * Handles browser storage for exercises, scores, and settings\n */\n\nimport { EventEmitter } from '../utils/EventEmitter';\nimport { Exercise, ScoreResult, DrawingData } from '../types/Exercise';\n\n// Storage keys\nconst STORAGE_KEYS = {\n  EXERCISES: 'handwriting_exercises',\n  SETTINGS: 'handwriting_settings',\n  THUMBNAILS: 'handwriting_thumbnails'\n};\n\n// Settings interface\ninterface AppSettings {\n  volume: number;\n  muted: boolean;\n  lastExerciseId?: string;\n  username?: string;\n}\n\n// Thumbnail storage interface\ninterface ThumbnailStorage {\n  [exerciseId: string]: string; // exercise ID -> data URL\n}\n\n// Serialized exercise from localStorage (with date as string)\ninterface SerializedExercise extends Omit<Exercise, 'createdAt'> {\n  createdAt: string;\n}\n\nexport class StorageManager extends EventEmitter {\n  private exercises: Exercise[] = [];\n  private settings: AppSettings = {\n    volume: 0.5,\n    muted: false\n  };\n  private thumbnails: ThumbnailStorage = {};\n  private initialized: boolean = false;\n  \n  /**\n   * Initialize the storage manager\n   */\n  public async initialize(): Promise<void> {\n    if (this.initialized) {\n      return Promise.resolve();\n    }\n    \n    try {\n      // Load exercises\n      await this.loadExercises();\n      \n      // Load settings\n      await this.loadSettings();\n      \n      // Load thumbnails\n      await this.loadThumbnails();\n      \n      this.initialized = true;\n      this.emit('storage-initialized');\n      \n      return Promise.resolve();\n    } catch (error) {\n      console.error('Failed to initialize storage manager:', error);\n      return Promise.reject(error);\n    }\n  }\n  \n  /**\n   * Load exercises from localStorage\n   */\n  private async loadExercises(): Promise<void> {\n    try {\n      const exercisesJson = localStorage.getItem(STORAGE_KEYS.EXERCISES);\n      \n      if (exercisesJson) {\n        const exercisesData = JSON.parse(exercisesJson);\n        \n        // Convert stored dates back to Date objects\n        this.exercises = exercisesData.map((exercise: SerializedExercise) => ({\n          ...exercise,\n          createdAt: new Date(exercise.createdAt)\n        }));\n        \n        this.emit('exercises-loaded', this.exercises);\n      } else {\n        this.exercises = [];\n      }\n      \n      return Promise.resolve();\n    } catch (error) {\n      console.error('Failed to load exercises:', error);\n      this.exercises = [];\n      return Promise.reject(error);\n    }\n  }\n  \n  /**\n   * Load settings from localStorage\n   */\n  private async loadSettings(): Promise<void> {\n    try {\n      const settingsJson = localStorage.getItem(STORAGE_KEYS.SETTINGS);\n      \n      if (settingsJson) {\n        this.settings = JSON.parse(settingsJson);\n      }\n      \n      return Promise.resolve();\n    } catch (error) {\n      console.error('Failed to load settings:', error);\n      return Promise.resolve();\n    }\n  }\n  \n  /**\n   * Load thumbnails from localStorage\n   */\n  private async loadThumbnails(): Promise<void> {\n    try {\n      const thumbnailsJson = localStorage.getItem(STORAGE_KEYS.THUMBNAILS);\n      \n      if (thumbnailsJson) {\n        this.thumbnails = JSON.parse(thumbnailsJson);\n      } else {\n        this.thumbnails = {};\n      }\n      \n      return Promise.resolve();\n    } catch (error) {\n      console.error('Failed to load thumbnails:', error);\n      this.thumbnails = {};\n      return Promise.resolve();\n    }\n  }\n  \n  /**\n   * Get all exercises\n   * @returns Array of exercises\n   */\n  public getExercises(): Exercise[] {\n    return [...this.exercises].sort((a, b) => \n      b.createdAt.getTime() - a.createdAt.getTime()\n    );\n  }\n  \n  /**\n   * Get a specific exercise by ID\n   * @param id - Exercise ID\n   * @returns Exercise or undefined if not found\n   */\n  public getExerciseById(id: string): Exercise | undefined {\n    return this.exercises.find(exercise => exercise.id === id);\n  }\n  \n  /**\n   * Save a new exercise\n   * @param exercise - Exercise to save\n   * @returns Promise that resolves when save is complete\n   */\n  public async saveExercise(exercise: Exercise): Promise<void> {\n    try {\n      // Add to exercises array\n      this.exercises.push(exercise);\n      \n      // Save to localStorage\n      await this.persistExercises();\n      \n      // Generate and save thumbnail\n      await this.generateAndSaveThumbnail(exercise);\n      \n      // Emit event\n      this.emit('exercise-saved', exercise);\n      \n      return Promise.resolve();\n    } catch (error) {\n      console.error('Failed to save exercise:', error);\n      return Promise.reject(error);\n    }\n  }\n  \n  /**\n   * Update an existing exercise\n   * @param updatedExercise - Updated exercise data\n   * @returns Promise that resolves when update is complete\n   */\n  public async updateExercise(updatedExercise: Exercise): Promise<void> {\n    try {\n      // Find exercise index\n      const index = this.exercises.findIndex(e => e.id === updatedExercise.id);\n      \n      if (index === -1) {\n        throw new Error(`Exercise with ID ${updatedExercise.id} not found`);\n      }\n      \n      // Update exercise\n      this.exercises[index] = updatedExercise;\n      \n      // Save to localStorage\n      await this.persistExercises();\n      \n      // Update thumbnail if adult drawing changed\n      if (updatedExercise.adultDrawing) {\n        await this.generateAndSaveThumbnail(updatedExercise);\n      }\n      \n      // Emit event\n      this.emit('exercise-updated', updatedExercise);\n      \n      return Promise.resolve();\n    } catch (error) {\n      console.error('Failed to update exercise:', error);\n      return Promise.reject(error);\n    }\n  }\n  \n  /**\n   * Delete an exercise\n   * @param id - ID of exercise to delete\n   * @returns Promise that resolves when deletion is complete\n   */\n  public async deleteExercise(id: string): Promise<void> {\n    try {\n      // Find exercise index\n      const index = this.exercises.findIndex(e => e.id === id);\n      \n      if (index === -1) {\n        throw new Error(`Exercise with ID ${id} not found`);\n      }\n      \n      // Remove exercise\n      const deletedExercise = this.exercises.splice(index, 1)[0];\n      \n      // Save to localStorage\n      await this.persistExercises();\n      \n      // Delete thumbnail\n      delete this.thumbnails[id];\n      await this.persistThumbnails();\n      \n      // Emit event\n      this.emit('exercise-deleted', deletedExercise);\n      \n      return Promise.resolve();\n    } catch (error) {\n      console.error('Failed to delete exercise:', error);\n      return Promise.reject(error);\n    }\n  }\n  \n  /**\n   * Save exercise result (score)\n   * @param exercise - Exercise with attempts\n   * @param score - Score result\n   * @returns Promise that resolves when save is complete\n   */\n  public async saveExerciseResult(exercise: Exercise, score: ScoreResult): Promise<void> {\n    try {\n      // Find exercise\n      const existingExercise = this.getExerciseById(exercise.id);\n      \n      if (!existingExercise) {\n        throw new Error(`Exercise with ID ${exercise.id} not found`);\n      }\n      \n      // Check if this is a new high score\n      const isHighScore = !existingExercise.highestScore || \n                          score.totalScore > existingExercise.highestScore.totalScore;\n      \n      // Update exercise with attempts and potentially new high score\n      const updatedExercise: Exercise = {\n        ...existingExercise,\n        attempts: exercise.attempts,\n        highestScore: isHighScore ? score : existingExercise.highestScore\n      };\n      \n      // Save updated exercise\n      await this.updateExercise(updatedExercise);\n      \n      // Emit event\n      this.emit('exercise-result-saved', { exercise: updatedExercise, score, isHighScore });\n      \n      return Promise.resolve();\n    } catch (error) {\n      console.error('Failed to save exercise result:', error);\n      return Promise.reject(error);\n    }\n  }\n  \n  /**\n   * Generate and save thumbnail for an exercise\n   * @param exercise - Exercise to generate thumbnail for\n   * @returns Promise that resolves when thumbnail is saved\n   */\n  private async generateAndSaveThumbnail(exercise: Exercise): Promise<void> {\n    try {\n      // Generate thumbnail\n      const thumbnailDataUrl = await this.generateThumbnail(exercise.adultDrawing);\n      \n      // Save thumbnail\n      this.thumbnails[exercise.id] = thumbnailDataUrl;\n      \n      // Persist thumbnails\n      await this.persistThumbnails();\n      \n      return Promise.resolve();\n    } catch (error) {\n      console.error('Failed to generate and save thumbnail:', error);\n      return Promise.reject(error);\n    }\n  }\n  \n  /**\n   * Generate a thumbnail from drawing data\n   * @param drawingData - Drawing data to generate thumbnail from\n   * @returns Promise that resolves with thumbnail data URL\n   */\n  private async generateThumbnail(drawingData: DrawingData): Promise<string> {\n    return new Promise((resolve, reject) => {\n      try {\n        // Create a small canvas for the thumbnail\n        const canvas = document.createElement('canvas');\n        canvas.width = 100;\n        canvas.height = 100;\n        \n        const context = canvas.getContext('2d');\n        \n        if (!context) {\n          throw new Error('Could not get canvas context');\n        }\n        \n        // Clear canvas\n        context.fillStyle = '#FFFFFF';\n        context.fillRect(0, 0, canvas.width, canvas.height);\n        \n        // If no strokes, return blank thumbnail\n        if (drawingData.strokes.length === 0) {\n          resolve(canvas.toDataURL('image/png'));\n          return;\n        }\n        \n        // Find bounding box of original drawing\n        let minX = Number.MAX_VALUE;\n        let maxX = Number.MIN_VALUE;\n        let minY = Number.MAX_VALUE;\n        let maxY = Number.MIN_VALUE;\n        \n        for (const stroke of drawingData.strokes) {\n          for (const point of stroke.points) {\n            minX = Math.min(minX, point.x);\n            maxX = Math.max(maxX, point.x);\n            minY = Math.min(minY, point.y);\n            maxY = Math.max(maxY, point.y);\n          }\n        }\n        \n        // Calculate scale and offset to fit in thumbnail\n        const originalWidth = maxX - minX;\n        const originalHeight = maxY - minY;\n        \n        // Prevent division by zero\n        if (originalWidth === 0 || originalHeight === 0) {\n          resolve(canvas.toDataURL('image/png'));\n          return;\n        }\n        \n        // Calculate scale to fit in thumbnail with padding\n        const padding = 10;\n        const availableWidth = canvas.width - (padding * 2);\n        const availableHeight = canvas.height - (padding * 2);\n        const scale = Math.min(\n          availableWidth / originalWidth,\n          availableHeight / originalHeight\n        );\n        \n        // Calculate centering offset\n        const offsetX = padding + (availableWidth - (originalWidth * scale)) / 2;\n        const offsetY = padding + (availableHeight - (originalHeight * scale)) / 2;\n        \n        // Draw each stroke\n        for (const stroke of drawingData.strokes) {\n          if (stroke.points.length < 2) continue;\n          \n          context.beginPath();\n          context.strokeStyle = stroke.color;\n          context.lineWidth = Math.max(1, stroke.width * scale * 0.5);\n          context.lineCap = 'round';\n          context.lineJoin = 'round';\n          \n          // First point\n          const firstPoint = stroke.points[0];\n          const scaledX1 = offsetX + (firstPoint.x - minX) * scale;\n          const scaledY1 = offsetY + (firstPoint.y - minY) * scale;\n          context.moveTo(scaledX1, scaledY1);\n          \n          // Rest of the points\n          for (let i = 1; i < stroke.points.length; i++) {\n            const point = stroke.points[i];\n            const scaledX = offsetX + (point.x - minX) * scale;\n            const scaledY = offsetY + (point.y - minY) * scale;\n            context.lineTo(scaledX, scaledY);\n          }\n          \n          context.stroke();\n        }\n        \n        // Convert canvas to data URL\n        resolve(canvas.toDataURL('image/png'));\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n  \n  /**\n   * Get thumbnail for an exercise\n   * @param exerciseId - Exercise ID\n   * @returns Thumbnail data URL or undefined if not found\n   */\n  public getThumbnail(exerciseId: string): string | undefined {\n    return this.thumbnails[exerciseId];\n  }\n  \n  /**\n   * Save settings\n   * @param settings - Settings to save\n   * @returns Promise that resolves when save is complete\n   */\n  public async saveSettings(settings: Partial<AppSettings>): Promise<void> {\n    try {\n      // Update settings\n      this.settings = { ...this.settings, ...settings };\n      \n      // Save to localStorage\n      localStorage.setItem(STORAGE_KEYS.SETTINGS, JSON.stringify(this.settings));\n      \n      // Emit event\n      this.emit('settings-saved', this.settings);\n      \n      return Promise.resolve();\n    } catch (error) {\n      console.error('Failed to save settings:', error);\n      return Promise.reject(error);\n    }\n  }\n  \n  /**\n   * Get current settings\n   * @returns Current settings\n   */\n  public getSettings(): AppSettings {\n    return { ...this.settings };\n  }\n  \n  /**\n   * Persist exercises to localStorage\n   */\n  private async persistExercises(): Promise<void> {\n    try {\n      localStorage.setItem(STORAGE_KEYS.EXERCISES, JSON.stringify(this.exercises));\n      return Promise.resolve();\n    } catch (error) {\n      console.error('Failed to persist exercises:', error);\n      return Promise.reject(error);\n    }\n  }\n  \n  /**\n   * Persist thumbnails to localStorage\n   */\n  private async persistThumbnails(): Promise<void> {\n    try {\n      localStorage.setItem(STORAGE_KEYS.THUMBNAILS, JSON.stringify(this.thumbnails));\n      return Promise.resolve();\n    } catch (error) {\n      console.error('Failed to persist thumbnails:', error);\n      return Promise.reject(error);\n    }\n  }\n}\n","/**\n * AudioManager class\n * Handles all audio effects using Web Audio API oscillators\n */\n\nimport { EventEmitter } from '../utils/EventEmitter';\n\n// Envelope parameters for sound shaping\ninterface EnvelopeParams {\n  attack: number; // Attack time in seconds\n  decay: number; // Decay time in seconds\n  sustain: number; // Sustain level (0-1)\n  release: number; // Release time in seconds\n}\n\n// Note parameters for oscillator\ninterface NoteParams {\n  frequency: number; // Frequency in Hz\n  type: OscillatorType; // Oscillator type\n  duration: number; // Duration in seconds\n  gain: number; // Gain (0-1)\n  envelope?: EnvelopeParams; // Optional envelope\n}\n\nexport class AudioManager extends EventEmitter {\n  private audioContext: AudioContext | null = null;\n  private masterGain: GainNode | null = null;\n  private activeOscillators: Map<string, OscillatorNode> = new Map();\n  private activeGains: Map<string, GainNode> = new Map();\n  private muted: boolean = false;\n\n  // --- Continuous stroke sound state ---\n  private strokeOscillator: OscillatorNode | null = null;\n  private strokeGain: GainNode | null = null;\n  private strokeStartY: number | null = null;\n  private strokePaused: boolean = false;\n  // Oscillator and gain for X-axis differentiation\n  private strokeOscillatorX: OscillatorNode | null = null;\n  private strokeGainX: GainNode | null = null;\n  // Starting X position for stroke\n  private strokeStartX: number | null = null;\n  // Default gains for continuous stroke oscillators\n  private defaultStrokeYGain: number = 0.08;\n  private defaultStrokeXGain: number = 0.02;\n\n  /**\n   * Initialize the audio manager\n   */\n  public async initialize(): Promise<void> {\n    try {\n      // Create audio context\n      this.audioContext = new AudioContext();\n\n      // Create master gain node\n      this.masterGain = this.audioContext.createGain();\n      this.masterGain.gain.value = 0.5; // 50% volume by default\n      this.masterGain.connect(this.audioContext.destination);\n\n      // Defer resume until user gesture due to autoplay policies\n      if (this.audioContext.state === 'suspended') {\n        const resumeOnGesture = async (): Promise<void> => {\n          try {\n            await this.audioContext!.resume();\n            console.log('AudioContext resumed after user interaction');\n          } catch (err) {\n            console.error('Failed to resume audio context:', err);\n          }\n          document.removeEventListener('click', resumeOnGesture);\n          document.removeEventListener('touchstart', resumeOnGesture);\n        };\n        document.addEventListener('click', resumeOnGesture, { once: true });\n        document.addEventListener('touchstart', resumeOnGesture, { once: true });\n      }\n\n      this.emit('audio-initialized');\n      return Promise.resolve();\n    } catch (error) {\n      console.error('Failed to initialize audio manager:', error);\n      return Promise.reject(error);\n    }\n  }\n\n  /**\n   * Set master volume\n   * @param volume - Volume level (0-1)\n   */\n  public setVolume(volume: number): void {\n    if (!this.audioContext || !this.masterGain) return;\n\n    // Clamp volume to 0-1 range\n    const clampedVolume = Math.max(0, Math.min(1, volume));\n\n    // Apply volume with slight ramp to avoid clicks\n    this.masterGain.gain.linearRampToValueAtTime(\n      clampedVolume,\n      this.audioContext.currentTime + 0.02\n    );\n  }\n\n  /**\n   * Mute/unmute all audio\n   * @param muted - Whether audio should be muted\n   */\n  public setMuted(muted: boolean): void {\n    this.muted = muted;\n\n    if (!this.audioContext || !this.masterGain) return;\n\n    // Apply mute/unmute with slight ramp to avoid clicks\n    this.masterGain.gain.linearRampToValueAtTime(\n      muted ? 0 : 0.5, // 0 for muted, 0.5 for unmuted\n      this.audioContext.currentTime + 0.02\n    );\n  }\n\n  /**\n   * Play a completion sound when an attempt is completed\n   */\n  public playAttemptCompleteSound(): void {\n    if (!this.audioContext || this.muted) return;\n\n    // Play a rising arpeggio\n    const notes: NoteParams[] = [\n      {\n        frequency: 440, // A4\n        type: 'sine',\n        duration: 0.1,\n        gain: 0.3,\n        envelope: { attack: 0.01, decay: 0.05, sustain: 0.5, release: 0.1 },\n      },\n      {\n        frequency: 523.25, // C5\n        type: 'sine',\n        duration: 0.1,\n        gain: 0.3,\n        envelope: { attack: 0.01, decay: 0.05, sustain: 0.5, release: 0.1 },\n      },\n      {\n        frequency: 659.25, // E5\n        type: 'sine',\n        duration: 0.2,\n        gain: 0.3,\n        envelope: { attack: 0.01, decay: 0.1, sustain: 0.5, release: 0.2 },\n      },\n    ];\n\n    // Play notes with slight delay between them\n    notes.forEach((note, index) => {\n      setTimeout(() => {\n        this.playNote(note, `complete-${index}`);\n      }, index * 100);\n    });\n  }\n\n  /**\n   * Play a welcome sound when the game starts\n   */\n  public playWelcomeSound(): void {\n    if (!this.audioContext || this.muted) return;\n\n    // Play a gentle chord\n    const notes: NoteParams[] = [\n      {\n        frequency: 277.18, // C#4\n        type: 'sine',\n        duration: 1.0,\n        gain: 0.2,\n        envelope: { attack: 0.1, decay: 0.2, sustain: 0.6, release: 0.5 },\n      },\n      {\n        frequency: 349.23, // F4\n        type: 'sine',\n        duration: 1.0,\n        gain: 0.2,\n        envelope: { attack: 0.15, decay: 0.2, sustain: 0.6, release: 0.5 },\n      },\n      {\n        frequency: 440, // A4\n        type: 'sine',\n        duration: 1.0,\n        gain: 0.2,\n        envelope: { attack: 0.2, decay: 0.2, sustain: 0.6, release: 0.5 },\n      },\n    ];\n\n    // Play notes simultaneously\n    notes.forEach((note, index) => {\n      this.playNote(note, `welcome-${index}`);\n    });\n  }\n\n  /**\n   * Play a fanfare sound for the final score\n   */\n  public playFanfareSound(): void {\n    if (!this.audioContext || this.muted) return;\n\n    // Define a simple fanfare melody\n    const notes: NoteParams[] = [\n      // First chord\n      {\n        frequency: 440, // A4\n        type: 'triangle',\n        duration: 0.2,\n        gain: 0.3,\n        envelope: { attack: 0.01, decay: 0.1, sustain: 0.8, release: 0.1 },\n      },\n      {\n        frequency: 523.25, // C5\n        type: 'triangle',\n        duration: 0.2,\n        gain: 0.3,\n        envelope: { attack: 0.01, decay: 0.1, sustain: 0.8, release: 0.1 },\n      },\n      {\n        frequency: 659.25, // E5\n        type: 'triangle',\n        duration: 0.2,\n        gain: 0.3,\n        envelope: { attack: 0.01, decay: 0.1, sustain: 0.8, release: 0.1 },\n      },\n\n      // Trumpet-like fanfare\n      {\n        frequency: 587.33, // D5\n        type: 'square',\n        duration: 0.15,\n        gain: 0.25,\n        envelope: { attack: 0.01, decay: 0.05, sustain: 0.8, release: 0.05 },\n      },\n      {\n        frequency: 587.33, // D5\n        type: 'square',\n        duration: 0.15,\n        gain: 0.25,\n        envelope: { attack: 0.01, decay: 0.05, sustain: 0.8, release: 0.05 },\n      },\n      {\n        frequency: 784, // G5\n        type: 'square',\n        duration: 0.6,\n        gain: 0.3,\n        envelope: { attack: 0.01, decay: 0.3, sustain: 0.6, release: 0.3 },\n      },\n    ];\n\n    // Play chords simultaneously and melody sequentially\n    const firstChord = notes.slice(0, 3);\n    const fanfareMelody = notes.slice(3);\n\n    // Play first chord\n    firstChord.forEach((note, index) => {\n      this.playNote(note, `fanfare-chord-${index}`);\n    });\n\n    // Play fanfare melody with delays\n    let delay = 300; // ms\n    fanfareMelody.forEach((note, index) => {\n      setTimeout(() => {\n        this.playNote(note, `fanfare-melody-${index}`);\n      }, delay);\n      delay += note.duration * 1000;\n    });\n  }\n\n  /**\n   * Play a sound when stroke is being drawn\n   */\n  public playStrokeSound(): void {\n    if (!this.audioContext || this.muted) return;\n\n    // Very subtle short beep\n    const note: NoteParams = {\n      frequency: 880, // A5\n      type: 'sine',\n      duration: 0.03,\n      gain: 0.05, // Very quiet\n      envelope: { attack: 0.02, decay: 0.02, sustain: 0.5, release: 0.01 },\n    };\n\n    // Use a timestamp to ensure unique ID\n    this.playNote(note, `stroke-${Date.now()}`);\n  }\n\n  /**\n   * Play a sound when an attempt starts\n   */\n  public playAttemptStartSound(): void {\n    if (!this.audioContext || this.muted) return;\n\n    // Play a descending tone\n    const note: NoteParams = {\n      frequency: 659.25, // E5\n      type: 'sine',\n      duration: 0.3,\n      gain: 0.2,\n      envelope: { attack: 0.05, decay: 0.1, sustain: 0.5, release: 0.15 },\n    };\n\n    this.playNote(note, 'attempt-start');\n  }\n\n  /**\n   * Play a sound when drawing outside of constraint box\n   */\n  public playErrorSound(): void {\n    if (!this.audioContext || this.muted) return;\n\n    // Dissonant sound for error\n    const notes: NoteParams[] = [\n      {\n        frequency: 220, // A3\n        type: 'sine',\n        duration: 0.1,\n        gain: 0.15,\n        envelope: { attack: 0.01, decay: 0.05, sustain: 0.5, release: 0.05 },\n      },\n      {\n        frequency: 233.08, // Bb3 (slightly dissonant with A3)\n        type: 'sine',\n        duration: 0.1,\n        gain: 0.15,\n        envelope: { attack: 0.01, decay: 0.05, sustain: 0.5, release: 0.05 },\n      },\n    ];\n\n    // Play both notes simultaneously for dissonance\n    notes.forEach((note, index) => {\n      this.playNote(note, `error-${index}`);\n    });\n  }\n\n  /**\n   * Play a sound for each star earned in score\n   * @param starCount - Number of stars (1-5)\n   */\n  public playStarSound(starCount: number): void {\n    if (!this.audioContext || this.muted) return;\n\n    // Base frequency increases with each star\n    const baseFreq = 440 + starCount * 110; // A4, A4+, A5, etc.\n\n    const note: NoteParams = {\n      frequency: baseFreq,\n      type: 'sine',\n      duration: 0.15,\n      gain: 0.2,\n      envelope: { attack: 0.01, decay: 0.05, sustain: 0.5, release: 0.1 },\n    };\n\n    this.playNote(note, `star-${starCount}`);\n  }\n\n  /**\n   * Play a note with the given parameters\n   * @param params - Note parameters\n   * @param id - Unique ID for tracking the note\n   */\n  private playNote(params: NoteParams, id: string): void {\n    if (!this.audioContext || !this.masterGain) return;\n\n    // Create oscillator\n    const oscillator = this.audioContext.createOscillator();\n    oscillator.type = params.type;\n    oscillator.frequency.value = params.frequency;\n\n    // Create gain node for this note\n    const gainNode = this.audioContext.createGain();\n    gainNode.gain.value = 0; // Start silent\n\n    // Connect nodes: oscillator -> gain -> master -> output\n    oscillator.connect(gainNode);\n    gainNode.connect(this.masterGain);\n\n    // Store references for cleanup\n    this.activeOscillators.set(id, oscillator);\n    this.activeGains.set(id, gainNode);\n\n    // Get current time\n    const now = this.audioContext.currentTime;\n\n    // Apply envelope\n    const env = params.envelope || { attack: 0.01, decay: 0.1, sustain: 0.8, release: 0.1 };\n\n    // Attack\n    gainNode.gain.setValueAtTime(0, now);\n    gainNode.gain.linearRampToValueAtTime(params.gain, now + env.attack);\n\n    // Decay to sustain\n    gainNode.gain.linearRampToValueAtTime(params.gain * env.sustain, now + env.attack + env.decay);\n\n    // Start oscillator\n    oscillator.start(now);\n\n    // Release and stop\n    const stopTime = now + params.duration;\n    gainNode.gain.linearRampToValueAtTime(0, stopTime + env.release);\n    oscillator.stop(stopTime + env.release);\n\n    // Clean up after oscillator stops\n    oscillator.onended = (): void => {\n      this.activeOscillators.delete(id);\n      this.activeGains.delete(id);\n      oscillator.disconnect();\n      gainNode.disconnect();\n    };\n  }\n\n  /**\n   * Clean up all audio resources\n   */\n  public cleanup(): void {\n    // Stop all active oscillators\n    this.activeOscillators.forEach((oscillator, id) => {\n      try {\n        oscillator.stop();\n        oscillator.disconnect();\n      } catch (error) {\n        console.warn(`Failed to stop oscillator ${id}:`, error);\n      }\n    });\n\n    // Disconnect all gain nodes\n    this.activeGains.forEach(gain => {\n      try {\n        gain.disconnect();\n      } catch (error) {\n        console.warn('Failed to disconnect gain node:', error);\n      }\n    });\n\n    // Clear references\n    this.activeOscillators.clear();\n    this.activeGains.clear();\n\n    // Close audio context if supported\n    if (this.audioContext && this.audioContext.state !== 'closed') {\n      if (this.audioContext.close) {\n        this.audioContext.close().catch(error => {\n          console.error('Failed to close audio context:', error);\n        });\n      }\n    }\n\n    this.audioContext = null;\n    this.masterGain = null;\n  }\n\n  /**\n   * Start a continuous stroke sound with a second oscillator for X-axis. Call this when the stroke begins.\n   * @param x0 - The starting X position of the stroke\n   * @param y0 - The starting Y position of the stroke\n   */\n  public startStrokeSound(x0: number, y0: number): void {\n    if (!this.audioContext || !this.masterGain || this.muted) {\n      return;\n    }\n    this.stopStrokeSound(); // Ensure no previous stroke sound is running\n\n    this.strokeOscillator = this.audioContext.createOscillator();\n    this.strokeOscillator.type = 'sine';\n    // Initial frequency (can be updated immediately after)\n    this.strokeOscillator.frequency.value = 440;\n\n    this.strokeGain = this.audioContext.createGain();\n    // Start silent for fade-in\n    this.strokeGain.gain.value = 0;\n\n    this.strokeOscillator.connect(this.strokeGain);\n    // Create second oscillator for X-axis\n    this.strokeOscillatorX = this.audioContext.createOscillator();\n    this.strokeOscillatorX.type = 'triangle';\n    this.strokeOscillatorX.frequency.value = 440;\n    this.strokeGainX = this.audioContext.createGain();\n    this.strokeGainX.gain.value = 0;\n    this.strokeOscillatorX.connect(this.strokeGainX);\n    // Connect secondary X-axis gain to master output\n    this.strokeGainX.connect(this.masterGain);\n    // Connect primary Y-axis oscillator\n    this.strokeGain.connect(this.masterGain);\n\n    this.strokeOscillator.start();\n    this.strokeOscillatorX.start();\n    this.strokeStartX = x0;\n    this.strokeStartY = y0;\n    this.strokePaused = false;\n\n    // Fade in to 0.08 over 100ms\n    if (this.audioContext) {\n      const now = this.audioContext.currentTime;\n      // Y-axis fade-in to configurable gain\n      this.strokeGain.gain.setValueAtTime(0, now);\n      this.strokeGain.gain.linearRampToValueAtTime(this.defaultStrokeYGain, now + 0.1);\n      // X-axis fade-in to configurable gain\n      this.strokeGainX!.gain.setValueAtTime(0, now);\n      this.strokeGainX!.gain.linearRampToValueAtTime(this.defaultStrokeXGain, now + 0.1);\n    }\n  }\n\n  /**\n   * Update the pitch of the stroke sound oscillators based on current Y (primary) and X (secondary) positions.\n   * @param x - The current X position\n   * @param y - The current Y position\n   */\n  public updateStrokeSound(x: number, y: number): void {\n    // Guard: ensure oscillators and start positions are initialized\n    if (\n      !this.strokeOscillator ||\n      !this.strokeOscillatorX ||\n      this.strokeStartY === null ||\n      this.strokeStartX === null\n    ) {\n      return;\n    }\n    // Compute primary Y-axis frequency (e.g., 220 Hz to 880 Hz)\n    const minFreq = 220;\n    const maxFreq = 880;\n    const maxDeltaY = 400;\n    const deltaY = -Math.max(-maxDeltaY, Math.min(maxDeltaY, y - this.strokeStartY));\n    const normY = (deltaY + maxDeltaY) / (8 * maxDeltaY);\n    const freq = minFreq + (maxFreq - minFreq) * normY;\n    this.strokeOscillator.frequency.setValueAtTime(freq, this.audioContext!.currentTime);\n\n    // Apply X-axis delta as frequency offset to the secondary oscillator\n    const maxDeltaX = 800;\n    const deltaX = Math.max(-maxDeltaX, Math.min(maxDeltaX, x - this.strokeStartX));\n    const panNormalized = deltaX / maxDeltaX; // -1 .. 1\n    const offsetRange = (maxFreq - minFreq) / 8; // one eigth of Y-axis range\n    const freqX = freq + panNormalized * offsetRange;\n    this.strokeOscillatorX.frequency.setValueAtTime(freqX, this.audioContext!.currentTime);\n  }\n\n  /**\n   * Stop the continuous stroke sound. Call this when the stroke ends.\n   */\n  public stopStrokeSound(): void {\n    if (this.strokeOscillator) {\n      try {\n        // Fade out over 100ms\n        if (this.strokeGain && this.audioContext) {\n          this.strokeGain.gain.cancelScheduledValues(this.audioContext.currentTime);\n          this.strokeGain.gain.setValueAtTime(\n            this.strokeGain.gain.value,\n            this.audioContext.currentTime\n          );\n          this.strokeGain.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + 0.1);\n          if (this.strokeGainX) {\n            this.strokeGainX.gain.cancelScheduledValues(this.audioContext.currentTime);\n            this.strokeGainX.gain.setValueAtTime(\n              this.strokeGainX.gain.value,\n              this.audioContext.currentTime\n            );\n            this.strokeGainX.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + 0.1);\n          }\n        }\n        this.strokeOscillator.stop(this.audioContext!.currentTime + 0.11);\n        if (this.strokeOscillatorX) {\n          this.strokeOscillatorX.stop(this.audioContext!.currentTime + 0.11);\n        }\n      } catch (e) {\n        console.error('Failed to play stroke sound:', e);\n      }\n      this.strokeOscillator.disconnect();\n      if (this.strokeGain) {\n        this.strokeGain.disconnect();\n      }\n      if (this.strokeOscillatorX) {\n        this.strokeOscillatorX.disconnect();\n      }\n      if (this.strokeGainX) {\n        this.strokeGainX.disconnect();\n      }\n    }\n    this.strokeOscillator = null;\n    this.strokeGain = null;\n    this.strokeOscillatorX = null;\n    this.strokeGainX = null;\n    this.strokeStartY = null;\n    this.strokeStartX = null;\n    this.strokePaused = false;\n  }\n\n  public pauseStrokeSound(): void {\n    if (this.strokeGain && !this.strokePaused) {\n      // Mute both oscillators\n      this.strokeGain.gain.setValueAtTime(0, this.audioContext!.currentTime);\n      if (this.strokeGainX) {\n        this.strokeGainX.gain.setValueAtTime(0, this.audioContext!.currentTime);\n      }\n      this.strokePaused = true;\n    }\n  }\n\n  public resumeStrokeSound(): void {\n    if (this.strokeGain && this.strokePaused) {\n      // Restore both oscillators to configurable gains\n      this.strokeGain.gain.setValueAtTime(this.defaultStrokeYGain, this.audioContext!.currentTime);\n      if (this.strokeGainX) {\n        this.strokeGainX.gain.setValueAtTime(\n          this.defaultStrokeXGain,\n          this.audioContext!.currentTime\n        );\n      }\n      this.strokePaused = false;\n    }\n  }\n\n  /**\n   * Set the default Y-axis gain for continuous stroke sound (0-1).\n   */\n  public setStrokeYGain(gain: number): void {\n    const clamped = Math.max(0, Math.min(1, gain));\n    this.defaultStrokeYGain = clamped;\n    if (this.strokeGain && this.audioContext) {\n      this.strokeGain.gain.setValueAtTime(clamped, this.audioContext.currentTime);\n    }\n  }\n\n  /**\n   * Set the default X-axis gain for continuous stroke sound (0-1).\n   */\n  public setStrokeXGain(gain: number): void {\n    const clamped = Math.max(0, Math.min(1, gain));\n    this.defaultStrokeXGain = clamped;\n    if (this.strokeGainX && this.audioContext) {\n      this.strokeGainX.gain.setValueAtTime(clamped, this.audioContext.currentTime);\n    }\n  }\n}\n"],"names":["EventEmitter","events","Map","on","event","callback","this","has","set","callbacks","get","push","off","index","indexOf","splice","length","delete","emit","args","forEach","error","console","String","removeAllListeners","clear","STORAGE_KEYS","StorageManager","exercises","settings","volume","muted","thumbnails","initialized","initialize","Promise","resolve","loadExercises","loadSettings","loadThumbnails","reject","exercisesJson","localStorage","getItem","exercisesData","JSON","parse","map","exercise","createdAt","Date","settingsJson","thumbnailsJson","getExercises","sort","a","b","getTime","getExerciseById","id","find","saveExercise","persistExercises","generateAndSaveThumbnail","updateExercise","updatedExercise","findIndex","e","Error","adultDrawing","deleteExercise","deletedExercise","persistThumbnails","saveExerciseResult","score","existingExercise","isHighScore","highestScore","totalScore","attempts","thumbnailDataUrl","generateThumbnail","drawingData","canvas","document","createElement","width","height","context","getContext","fillStyle","fillRect","strokes","toDataURL","minX","Number","MAX_VALUE","maxX","MIN_VALUE","minY","maxY","stroke","point","points","Math","min","x","max","y","originalWidth","originalHeight","padding","availableWidth","availableHeight","scale","offsetX","offsetY","beginPath","strokeStyle","color","lineWidth","lineCap","lineJoin","firstPoint","scaledX1","scaledY1","moveTo","i","scaledX","scaledY","lineTo","getThumbnail","exerciseId","saveSettings","setItem","stringify","getSettings","AudioManager","audioContext","masterGain","activeOscillators","activeGains","strokeOscillator","strokeGain","strokeStartY","strokePaused","strokeOscillatorX","strokeGainX","strokeStartX","defaultStrokeYGain","defaultStrokeXGain","AudioContext","createGain","gain","value","connect","destination","state","resumeOnGesture","async","resume","log","err","removeEventListener","addEventListener","once","setVolume","clampedVolume","linearRampToValueAtTime","currentTime","setMuted","playAttemptCompleteSound","frequency","type","duration","envelope","attack","decay","sustain","release","note","setTimeout","playNote","playWelcomeSound","playFanfareSound","notes","firstChord","slice","fanfareMelody","delay","playStrokeSound","now","playAttemptStartSound","playErrorSound","playStarSound","starCount","params","oscillator","createOscillator","gainNode","env","setValueAtTime","start","stopTime","stop","onended","disconnect","cleanup","warn","close","catch","startStrokeSound","x0","y0","stopStrokeSound","updateStrokeSound","freq","freqX","cancelScheduledValues","pauseStrokeSound","resumeStrokeSound","setStrokeYGain","clamped","setStrokeXGain"],"mappings":"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"}