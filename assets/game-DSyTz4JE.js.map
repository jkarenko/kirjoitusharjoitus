{"version":3,"file":"game-DSyTz4JE.js","sources":["../../src/core/GameManager.ts","../../src/core/DrawingManager.ts","../../src/core/ScoreManager.ts"],"sourcesContent":["/**\n * GameManager class\n * Central coordinator for the handwriting exercise game\n */\n\nimport { DrawingManager } from './DrawingManager';\nimport { ScoreManager } from './ScoreManager';\nimport { StorageManager } from '../services/StorageManager';\nimport { AudioManager } from '../services/AudioManager';\nimport { UIManager } from '../services/UIManager';\nimport { Exercise, ConstraintBoxSize, ScoreResult, Point } from '../types/Exercise';\nimport { EventEmitter } from '../utils/EventEmitter';\n\n/**\n * GameManager options\n */\ninterface GameManagerOptions {\n  storageManager: StorageManager;\n  audioManager: AudioManager;\n  uiManager: UIManager;\n  drawingManager: DrawingManager;\n  scoreManager: ScoreManager;\n  container: HTMLElement;\n}\n\n/**\n * Game state\n */\ninterface GameState {\n  currentExercise: Exercise | null;\n  currentAttempt: number;\n  isPlaying: boolean;\n  isCreatingExercise: boolean;\n}\n\nexport class GameManager {\n  // Core managers\n  private storageManager: StorageManager;\n  private audioManager: AudioManager;\n  private uiManager: UIManager;\n  private drawingManager: DrawingManager;\n  private scoreManager: ScoreManager;\n\n  // Game state\n  private state: GameState = {\n    currentExercise: null,\n    currentAttempt: 0,\n    isPlaying: false,\n    isCreatingExercise: false,\n  };\n\n  // Constants\n  private readonly MAX_ATTEMPTS = 5;\n\n  /**\n   * Create a new GameManager\n   * @param options - Options for initializing the game manager\n   */\n  constructor(options: GameManagerOptions) {\n    this.storageManager = options.storageManager;\n    this.audioManager = options.audioManager;\n    this.uiManager = options.uiManager;\n    this.drawingManager = options.drawingManager;\n    this.scoreManager = options.scoreManager;\n\n    // Bind methods to maintain context\n    this.handleCreateExercise = this.handleCreateExercise.bind(this);\n    this.handleLoadExercise = this.handleLoadExercise.bind(this);\n    this.handleExerciseSelected = this.handleExerciseSelected.bind(this);\n    this.handleSaveExercise = this.handleSaveExercise.bind(this);\n    this.handleCancelExercise = this.handleCancelExercise.bind(this);\n    this.handleDoneButtonClicked = this.handleDoneButtonClicked.bind(this);\n    this.handleAttemptAnimationComplete = this.handleAttemptAnimationComplete.bind(this);\n    this.handleBackToMenu = this.handleBackToMenu.bind(this);\n    this.handleTryAgain = this.handleTryAgain.bind(this);\n    this.startNextAttempt = this.startNextAttempt.bind(this);\n  }\n\n  /**\n   * Initialize the game manager\n   */\n  public async initialize(): Promise<void> {\n    console.log('Initializing game manager...');\n\n    // Set up event listeners\n    this.setupEventListeners();\n\n    // Set up drawing canvas\n    this.setupDrawingCanvas();\n\n    return Promise.resolve();\n  }\n\n  /**\n   * Setup event listeners\n   */\n  private setupEventListeners(): void {\n    // UI Manager events\n    this.uiManager.on('create-template-clicked', this.handleCreateExercise);\n    this.uiManager.on('load-template-clicked', this.handleLoadExercise);\n    this.uiManager.on('exercise-selected', (exercise: unknown) =>\n      this.handleExerciseSelected(exercise as Exercise)\n    );\n    this.uiManager.on('save-exercise-clicked', (data: unknown) =>\n      this.handleSaveExercise(data as { name: string })\n    );\n    this.uiManager.on('cancel-exercise-clicked', this.handleCancelExercise);\n    this.uiManager.on('done-button-clicked', this.handleDoneButtonClicked);\n    this.uiManager.on('attempt-animation-complete', (attemptNumber: unknown) =>\n      this.handleAttemptAnimationComplete(attemptNumber as number)\n    );\n    this.uiManager.on('back-to-menu-clicked', this.handleBackToMenu);\n    this.uiManager.on('try-again-clicked', this.handleTryAgain);\n    this.uiManager.on('back-clicked', this.handleBackToMenu);\n    this.uiManager.on('star-added', (starCount: unknown) => {\n      this.audioManager.playStarSound(starCount as number);\n    });\n\n    // Drawing and Example Animation events (for sound)\n    let strokePauseTimer: ReturnType<typeof setTimeout> | null = null;\n    const PAUSE_DELAY = 120; // ms\n    let strokeSoundStarted = false;\n\n    const setupStrokeSoundListeners = (emitter: EventEmitter): void => {\n      emitter.on('stroke-started', () => {\n        strokeSoundStarted = false;\n      });\n      emitter.on('point-added', (...args) => {\n        const point = args[0] as Point;\n        if (point && typeof point.y === 'number') {\n          if (!strokeSoundStarted) {\n            this.audioManager.startStrokeSound(point.y);\n            strokeSoundStarted = true;\n          } else {\n            this.audioManager.updateStrokeSound(point.y);\n          }\n          this.audioManager.resumeStrokeSound();\n          if (strokePauseTimer) {\n            clearTimeout(strokePauseTimer);\n          }\n          strokePauseTimer = setTimeout(() => {\n            this.audioManager.pauseStrokeSound();\n          }, PAUSE_DELAY);\n        }\n      });\n      emitter.on('stroke-completed', () => {\n        if (strokePauseTimer) {\n          clearTimeout(strokePauseTimer);\n        }\n        this.audioManager.pauseStrokeSound();\n        this.audioManager.stopStrokeSound();\n        this.audioManager.playStrokeSound(); // keep the short beep for stroke end\n        strokeSoundStarted = false;\n      });\n    };\n\n    setupStrokeSoundListeners(this.drawingManager);\n    setupStrokeSoundListeners(this.uiManager);\n  }\n\n  /**\n   * Setup drawing canvas\n   */\n  private setupDrawingCanvas(): void {\n    // Set initial canvas for drawing manager\n    const canvas = document.querySelector('.drawing-canvas') as HTMLCanvasElement;\n    if (canvas) {\n      this.drawingManager.setCanvas(canvas);\n    }\n  }\n\n  /**\n   * Show the welcome screen\n   */\n  public showWelcomeScreen(): void {\n    // Reset state\n    this.state.currentExercise = null;\n    this.state.currentAttempt = 0;\n    this.state.isPlaying = false;\n    this.state.isCreatingExercise = false;\n\n    // Show welcome view\n    this.uiManager.showView('welcome');\n\n    // Play welcome sound\n    // this.audioManager.playWelcomeSound();\n  }\n\n  /**\n   * Handle create exercise button click\n   */\n  private handleCreateExercise(): void {\n    console.log('GameManager: handleCreateExercise - user requested to create new template');\n    // Update state\n    this.state.isCreatingExercise = true;\n\n    // Switch to create exercise view\n    this.uiManager.showView('create-exercise');\n\n    // Reset drawing manager\n    this.drawingManager.reset();\n\n    // Get drawing canvas from the UI\n    const canvas = document.querySelector(\n      '.create-exercise-view .drawing-canvas'\n    ) as HTMLCanvasElement;\n    if (canvas) {\n      // Ensure canvas is sized to its container for correct drawing resolution\n      const parent = canvas.parentElement;\n      if (parent) {\n        const rect = parent.getBoundingClientRect();\n        const ratio = window.devicePixelRatio || 1;\n        canvas.width = rect.width * ratio;\n        canvas.height = rect.height * ratio;\n        canvas.style.width = `${rect.width}px`;\n        canvas.style.height = `${rect.height}px`;\n        this.drawingManager.setCanvas(canvas);\n        this.drawingManager.enable();\n      }\n    }\n  }\n\n  /**\n   * Handle load exercise button click\n   */\n  private handleLoadExercise(): void {\n    console.log('GameManager: handleLoadExercise - fetching saved templates');\n    // Get exercises from storage\n    const exercises = this.storageManager.getExercises();\n    console.log(\n      `GameManager: handleLoadExercise - loaded ${exercises.length} templates`,\n      exercises\n    );\n\n    // Get thumbnails\n    const thumbnails: { [exerciseId: string]: string } = {};\n    exercises.forEach(exercise => {\n      const thumbnail = this.storageManager.getThumbnail(exercise.id);\n      if (thumbnail) {\n        thumbnails[exercise.id] = thumbnail;\n      }\n    });\n\n    // Update exercise list in UI\n    this.uiManager.updateExerciseList(exercises, thumbnails);\n\n    // Show exercise list view\n    this.uiManager.showView('exercise-list');\n  }\n\n  /**\n   * Handle exercise selection\n   * @param exercise - Selected exercise\n   */\n  public handleExerciseSelected(exercise: Exercise): void {\n    console.log(\n      `GameManager: handleExerciseSelected - starting game for template id=${exercise.id} name=\"${exercise.name}\"`\n    );\n    // Update state\n    this.state.currentExercise = exercise;\n    this.state.currentAttempt = 0;\n    this.state.isPlaying = true;\n\n    // Reset history display\n    this.uiManager.resetHistoryDisplay();\n\n    // Switch to attempt view first so the example container is laid out and measurable\n    this.uiManager.showView('attempt');\n\n    // Show example drawing now that the view is visible\n    this.uiManager.showExampleDrawing(exercise.adultDrawing);\n\n    // After animation completes, start the first attempt and remove this listener\n    const onExampleComplete = (): void => {\n      this.startNextAttempt();\n      this.uiManager.off('example-animation-complete', onExampleComplete);\n    };\n    this.uiManager.on('example-animation-complete', onExampleComplete);\n  }\n\n  /**\n   * Start the next attempt\n   */\n  private startNextAttempt(): void {\n    this.state.currentAttempt++;\n\n    if (this.state.currentAttempt > this.MAX_ATTEMPTS) {\n      this.showScoreScreen();\n      return;\n    }\n\n    // Calculate constraint box size for current attempt\n    const boxSize = this.calculateConstraintBoxSize(this.state.currentAttempt);\n\n    // Set up attempt view\n    this.uiManager.setupAttemptView(this.state.currentAttempt, boxSize);\n\n    // Get drawing canvas from the UI\n    const canvas = document.querySelector('.attempt-view .drawing-canvas') as HTMLCanvasElement;\n    if (canvas) {\n      this.drawingManager.setCanvas(canvas);\n      this.drawingManager.reset();\n      this.drawingManager.enable();\n    }\n\n    // Play attempt start sound\n    this.audioManager.playAttemptStartSound();\n  }\n\n  /**\n   * Handle done button click\n   */\n  private handleDoneButtonClicked(): void {\n    if (!this.state.currentExercise) return;\n\n    // Disable drawing\n    this.drawingManager.disable();\n\n    // Get drawing data\n    const drawingData = this.drawingManager.getDrawingData();\n\n    // Save attempt\n    if (\n      this.state.currentExercise &&\n      this.state.currentAttempt > 0 &&\n      this.state.currentAttempt <= this.MAX_ATTEMPTS\n    ) {\n      // Ensure attempts array has enough slots\n      while (this.state.currentExercise.attempts.length < this.state.currentAttempt) {\n        this.state.currentExercise.attempts.push({\n          strokes: [],\n          totalTime: 0,\n          width: 0,\n          height: 0,\n          created: Date.now(),\n        });\n      }\n\n      // Save current attempt\n      this.state.currentExercise.attempts[this.state.currentAttempt - 1] = drawingData;\n    }\n\n    // Play sound\n    this.audioManager.playAttemptCompleteSound();\n\n    // Animate drawing to history\n    this.uiManager.animateDrawingToHistory(this.state.currentAttempt, drawingData);\n  }\n\n  /**\n   * Handle attempt animation complete\n   * @param attemptNumber - Completed attempt number\n   */\n  private handleAttemptAnimationComplete(attemptNumber: number): void {\n    // Start next attempt or show score\n    if (attemptNumber >= this.MAX_ATTEMPTS) {\n      this.showScoreScreen();\n    } else {\n      this.startNextAttempt();\n    }\n  }\n\n  /**\n   * Show score screen after all attempts\n   */\n  private showScoreScreen(): void {\n    if (!this.state.currentExercise) return;\n\n    // Calculate score\n    const score = this.scoreManager.calculateScore(\n      this.state.currentExercise.adultDrawing,\n      this.state.currentExercise.attempts\n    );\n\n    // Save score to exercise\n    this.saveExerciseResult(this.state.currentExercise, score);\n\n    // Show score screen\n    this.uiManager.showScoreScreen(score);\n\n    // Play fanfare sound\n    this.audioManager.playFanfareSound();\n  }\n\n  /**\n   * Save exercise result\n   * @param exercise - Exercise with attempts\n   * @param score - Score result\n   */\n  private async saveExerciseResult(exercise: Exercise, score: ScoreResult): Promise<void> {\n    try {\n      await this.storageManager.saveExerciseResult(exercise, score);\n    } catch (error) {\n      console.error('Failed to save exercise result:', error);\n      this.uiManager.showError('Failed to save your score');\n    }\n  }\n\n  /**\n   * Handle save exercise button click\n   * @param data - Exercise data with name\n   */\n  private handleSaveExercise(data: { name: string }): void {\n    // Get drawing data\n    const drawingData = this.drawingManager.getDrawingData();\n\n    // Create new exercise\n    const exercise: Exercise = {\n      id: Date.now().toString(),\n      name: data.name,\n      createdAt: new Date(),\n      adultDrawing: drawingData,\n      attempts: [],\n      highestScore: null,\n    };\n\n    // Save exercise\n    this.storageManager\n      .saveExercise(exercise)\n      .then(() => {\n        // Show confirmation\n        this.uiManager.showExerciseSavedConfirmation();\n\n        // Back to welcome screen\n        setTimeout(() => {\n          this.state.isCreatingExercise = false;\n          this.uiManager.showView('welcome');\n        }, 1500);\n      })\n      .catch(error => {\n        console.error('Failed to save exercise:', error);\n        this.uiManager.showError('Failed to save exercise');\n      });\n  }\n\n  /**\n   * Handle cancel exercise button click\n   */\n  private handleCancelExercise(): void {\n    // Update state\n    this.state.isCreatingExercise = false;\n\n    // Return to welcome screen\n    this.uiManager.showView('welcome');\n  }\n\n  /**\n   * Handle back to menu button click\n   */\n  private handleBackToMenu(): void {\n    // Reset state\n    this.state.currentExercise = null;\n    this.state.currentAttempt = 0;\n    this.state.isPlaying = false;\n    this.state.isCreatingExercise = false;\n\n    // Clean up UI\n    this.uiManager.cleanupAnimations();\n    this.uiManager.resetHistoryDisplay();\n\n    // Return to welcome screen\n    this.uiManager.showView('welcome');\n  }\n\n  /**\n   * Handle try again button click\n   */\n  private handleTryAgain(): void {\n    if (!this.state.currentExercise) return;\n\n    // Keep the current exercise, reset attempt\n    this.state.currentAttempt = 0;\n\n    // Clean up UI\n    this.uiManager.resetHistoryDisplay();\n\n    // Switch to attempt view first so the example container is laid out and measurable\n    this.uiManager.showView('attempt');\n\n    // Show example drawing again (location/scale will be reset)\n    this.uiManager.showExampleDrawing(this.state.currentExercise.adultDrawing);\n\n    // After animation, start first attempt\n    this.uiManager.on('example-animation-complete', () => {\n      this.startNextAttempt();\n      // Remove this one-time listener\n      this.uiManager.off('example-animation-complete', this.startNextAttempt);\n    });\n  }\n\n  /**\n   * Calculate constraint box size for a given attempt\n   * @param attemptNumber - Current attempt number (1-5)\n   * @returns Constraint box size\n   */\n  private calculateConstraintBoxSize(attemptNumber: number): ConstraintBoxSize {\n    // Use viewport size for base, matching UIManager\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    const minDimension = Math.min(width, height);\n    const baseSize = minDimension * 0.6; // 60% of smaller dimension\n\n    // For the first attempt, use full base size; shrink only for subsequent attempts\n    const scaleFactor = attemptNumber === 1 ? 1 : Math.max(0.4, 1 - (attemptNumber - 1) * 0.01);\n\n    return {\n      width: baseSize * scaleFactor,\n      height: baseSize * scaleFactor,\n    };\n  }\n\n  /**\n   * Start the game with a specific exercise (template)\n   * @param exercise - Selected exercise\n   */\n  public startGameWithExercise(exercise: Exercise): void {\n    this.handleExerciseSelected(exercise);\n  }\n}\n","/**\n * DrawingManager class\n * Manages drawing operations on the canvas\n */\n\nimport { EventEmitter } from '../utils/EventEmitter';\nimport { StrokeData, DrawingData } from '../types/Exercise';\n\nexport class DrawingManager extends EventEmitter {\n  private canvas: HTMLCanvasElement | null = null;\n  private context: CanvasRenderingContext2D | null = null;\n  private isDrawing: boolean = false;\n  private isEnabled: boolean = false;\n  private currentStroke: StrokeData | null = null;\n  private strokes: StrokeData[] = [];\n  private strokeCounter: number = 0;\n  private startTime: number = 0;\n  private endTime: number = 0;\n  private strokeColor: string = '#000000';\n  private strokeWidth: number = 3;\n\n  /**\n   * Initialize the drawing manager and canvas\n   * @param canvasElement - Optional canvas element to use instead of creating one\n   */\n  public initialize(canvasElement?: HTMLCanvasElement): void {\n    if (canvasElement) {\n      this.canvas = canvasElement;\n    } else {\n      this.canvas = document.createElement('canvas');\n      this.canvas.classList.add('drawing-canvas');\n    }\n\n    this.context = this.canvas.getContext('2d');\n\n    if (!this.context) {\n      throw new Error('Could not get canvas context');\n    }\n\n    this.setupEventListeners();\n    this.reset();\n  }\n\n  /**\n   * Set up event listeners for touch/mouse events\n   */\n  private setupEventListeners(): void {\n    if (!this.canvas) {\n      return;\n    }\n\n    // Touch events for mobile/tablet\n    this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this));\n    this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this));\n    this.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this));\n\n    // Mouse events for desktop\n    this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));\n    this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));\n    this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));\n    this.canvas.addEventListener('mouseleave', this.handleMouseUp.bind(this));\n  }\n\n  /**\n   * Reset the drawing manager\n   */\n  public reset(): void {\n    this.strokes = [];\n    this.strokeCounter = 0;\n    this.startTime = 0;\n    this.endTime = 0;\n    this.isDrawing = false;\n    this.currentStroke = null;\n\n    if (this.canvas && this.context) {\n      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    }\n  }\n\n  /**\n   * Enable drawing\n   */\n  public enable(): void {\n    this.isEnabled = true;\n    if (this.canvas) {\n      this.canvas.style.pointerEvents = 'auto';\n    }\n  }\n\n  /**\n   * Disable drawing\n   */\n  public disable(): void {\n    this.isEnabled = false;\n    this.isDrawing = false;\n    this.currentStroke = null;\n    if (this.canvas) {\n      this.canvas.style.pointerEvents = 'none';\n    }\n  }\n\n  /**\n   * Set stroke color\n   * @param color - CSS color string\n   */\n  public setStrokeColor(color: string): void {\n    this.strokeColor = color;\n  }\n\n  /**\n   * Set stroke width\n   * @param width - Width in pixels\n   */\n  public setStrokeWidth(width: number): void {\n    this.strokeWidth = width;\n  }\n\n  /**\n   * Handle touch start event\n   * @param event - Touch event\n   */\n  private handleTouchStart(event: TouchEvent): void {\n    if (!this.isEnabled) return;\n\n    event.preventDefault();\n\n    const touch = event.touches[0];\n    this.startStroke(touch.clientX, touch.clientY, touch.force);\n  }\n\n  /**\n   * Handle touch move event\n   * @param event - Touch event\n   */\n  private handleTouchMove(event: TouchEvent): void {\n    if (!this.isEnabled || !this.isDrawing) return;\n\n    event.preventDefault();\n\n    const touch = event.touches[0];\n    this.continueStroke(touch.clientX, touch.clientY, touch.force);\n  }\n\n  /**\n   * Handle touch end event\n   * @param event - Touch event\n   */\n  private handleTouchEnd(event: TouchEvent): void {\n    if (!this.isEnabled) return;\n\n    event.preventDefault();\n    this.endStroke();\n  }\n\n  /**\n   * Handle mouse down event\n   * @param event - Mouse event\n   */\n  private handleMouseDown(event: MouseEvent): void {\n    if (!this.isEnabled) return;\n\n    event.preventDefault();\n    this.startStroke(event.clientX, event.clientY);\n  }\n\n  /**\n   * Handle mouse move event\n   * @param event - Mouse event\n   */\n  private handleMouseMove(event: MouseEvent): void {\n    if (!this.isEnabled || !this.isDrawing) return;\n\n    event.preventDefault();\n    this.continueStroke(event.clientX, event.clientY);\n  }\n\n  /**\n   * Handle mouse up event\n   * @param event - Mouse event\n   */\n  private handleMouseUp(event: MouseEvent): void {\n    if (!this.isEnabled) return;\n\n    event.preventDefault();\n    this.endStroke();\n  }\n\n  /**\n   * Start a new stroke\n   * @param x - X coordinate\n   * @param y - Y coordinate\n   * @param pressure - Optional pressure value\n   */\n  private startStroke(x: number, y: number, pressure: number = 1): void {\n    if (!this.canvas || !this.context) return;\n\n    // Get canvas-relative coordinates\n    const rect = this.canvas.getBoundingClientRect();\n    const pixelRatio = this.canvas.width / rect.width;\n    const canvasX = (x - rect.left) * pixelRatio;\n    const canvasY = (y - rect.top) * pixelRatio;\n\n    const now = Date.now();\n\n    // If this is the first stroke, record start time\n    if (this.strokes.length === 0) {\n      this.startTime = now;\n    }\n\n    this.isDrawing = true;\n\n    // Create a new stroke\n    this.currentStroke = {\n      id: this.strokeCounter++,\n      points: [\n        {\n          x: canvasX,\n          y: canvasY,\n          timestamp: now,\n          pressure: pressure,\n        },\n      ],\n      startTime: now,\n      endTime: now,\n      color: this.strokeColor,\n      width: this.strokeWidth,\n    };\n\n    // Setup drawing style\n    this.context.lineWidth = 3;\n    this.context.lineCap = 'round';\n    this.context.lineJoin = 'round';\n    this.context.strokeStyle = this.strokeColor;\n    this.context.beginPath();\n    this.context.moveTo(canvasX, canvasY);\n\n    // Emit stroke start event\n    this.emit('stroke-started', this.currentStroke);\n  }\n\n  /**\n   * Continue the current stroke\n   * @param x - X coordinate\n   * @param y - Y coordinate\n   * @param pressure - Optional pressure value\n   */\n  private continueStroke(x: number, y: number, pressure: number = 1): void {\n    if (!this.canvas || !this.context || !this.currentStroke) return;\n\n    // Get canvas-relative coordinates\n    const rect = this.canvas.getBoundingClientRect();\n    const pixelRatio = this.canvas.width / rect.width;\n    const canvasX = (x - rect.left) * pixelRatio;\n    const canvasY = (y - rect.top) * pixelRatio;\n\n    const now = Date.now();\n\n    // Add point to the current stroke\n    this.currentStroke.points.push({\n      x: canvasX,\n      y: canvasY,\n      timestamp: now,\n      pressure: pressure,\n    });\n\n    // Draw line to the new point\n    this.context.lineTo(canvasX, canvasY);\n    this.context.stroke();\n    this.context.beginPath();\n    this.context.moveTo(canvasX, canvasY);\n\n    // Emit point added event\n    this.emit('point-added', {\n      x: canvasX,\n      y: canvasY,\n      timestamp: now,\n      pressure,\n    });\n  }\n\n  /**\n   * End the current stroke\n   */\n  private endStroke(): void {\n    if (!this.currentStroke) return;\n\n    const now = Date.now();\n    this.currentStroke.endTime = now;\n    this.endTime = now;\n\n    // Add the completed stroke to the strokes array\n    this.strokes.push(this.currentStroke);\n\n    this.isDrawing = false;\n    this.currentStroke = null;\n\n    // Emit stroke completed event\n    this.emit('stroke-completed', this.strokes[this.strokes.length - 1]);\n  }\n\n  /**\n   * Set the canvas element for drawing\n   * @param canvas - Canvas element\n   */\n  public setCanvas(canvas: HTMLCanvasElement): void {\n    this.canvas = canvas;\n    this.context = canvas.getContext('2d');\n    this.setupEventListeners();\n  }\n\n  /**\n   * Get the current canvas element\n   */\n  public getCanvas(): HTMLCanvasElement | null {\n    return this.canvas;\n  }\n\n  /**\n   * Get drawing data\n   */\n  public getDrawingData(): DrawingData {\n    return {\n      strokes: [...this.strokes],\n      totalTime: this.endTime - this.startTime,\n      width: this.canvas?.width || 0,\n      height: this.canvas?.height || 0,\n      created: Date.now(),\n    };\n  }\n}\n","/**\n * ScoreManager class\n * Handles the scoring system for comparing drawings\n */\n\nimport { EventEmitter } from '../utils/EventEmitter';\nimport {\n  DrawingData,\n  StrokeData,\n  Point,\n  ScoreResult,\n  ScoreCategories,\n  ConstraintBoxSize,\n} from '../types/Exercise';\n\nexport class ScoreManager extends EventEmitter {\n  // Constants for scoring\n  private readonly MAX_SCORE = 100;\n\n  // Weights for different scoring categories\n  private readonly WEIGHTS = {\n    accuracy: 0.5, // 50% of total score\n    strokes: 0.25, // 25% of total score\n    timing: 0.25, // 25% of total score\n  };\n\n  // Feedback templates\n  private readonly FEEDBACK = {\n    excellent: [\n      'Excellent work! Your drawing is spot on!',\n      'Amazing job! Your handwriting is fantastic!',\n      \"Perfect! You've mastered this drawing!\",\n    ],\n    veryGood: [\n      'Very good! Your drawing looks great!',\n      'Impressive work! Keep practicing!',\n      \"Great job! You're getting better each time!\",\n    ],\n    good: [\n      \"Good job! You're making progress!\",\n      'Nice work! Keep practicing!',\n      \"Well done! You're improving!\",\n    ],\n    fair: [\n      'Nice try! Keep practicing!',\n      'Good effort! Try to follow the example more closely!',\n      'Keep going! Practice makes perfect!',\n    ],\n    needsWork: [\n      \"Keep practicing! You'll get better each time!\",\n      'Good start! Try to follow the example more carefully!',\n      \"Don't give up! Every practice helps you improve!\",\n    ],\n  };\n\n  /**\n   * Initialize the score manager\n   */\n  public initialize(): void {\n    // No initialization needed for now\n  }\n\n  /**\n   * Calculate scores for a completed exercise\n   * @param example - The adult's example drawing\n   * @param attempts - The child's attempt drawings (typically 5)\n   * @param constraintBoxes - Optional array of constraint boxes for each attempt\n   * @returns Score result with stars and feedback\n   */\n  public calculateScore(\n    example: DrawingData,\n    attempts: DrawingData[],\n    constraintBoxes?: ConstraintBoxSize[]\n  ): ScoreResult {\n    // We'll focus on the final attempt for the primary score\n    const finalAttempt = attempts[attempts.length - 1];\n\n    if (!finalAttempt) {\n      throw new Error('No attempts provided for scoring');\n    }\n\n    // 1. Calculate accuracy score (path similarity)\n    const accuracyScore = this.calculateAccuracyScore(\n      example,\n      finalAttempt,\n      constraintBoxes?.[attempts.length - 1]\n    );\n    console.log('accuracyScore', accuracyScore);\n\n    // 2. Calculate strokes score (number and length of strokes)\n    const strokesScore = this.calculateStrokesScore(example, finalAttempt);\n    console.log('strokesScore', strokesScore);\n\n    // 3. Calculate timing score (rhythm and pace of drawing)\n    const timingScore = this.calculateTimingScore(example, finalAttempt);\n    console.log('timingScore', timingScore);\n\n    // 4. Calculate overall score\n    const overallScore = Math.round(\n      (accuracyScore * this.WEIGHTS.accuracy +\n        strokesScore * this.WEIGHTS.strokes +\n        timingScore * this.WEIGHTS.timing) *\n        this.MAX_SCORE\n    );\n    console.log('overallScore', overallScore);\n\n    // 5. Convert normalized scores (0-1) to star ratings (1-5)\n    const categories: ScoreCategories = {\n      accuracy: this.normalizedScoreToStars(accuracyScore),\n      strokes: this.normalizedScoreToStars(strokesScore),\n      timing: this.normalizedScoreToStars(timingScore),\n      overall: this.normalizedScoreToStars(overallScore / this.MAX_SCORE),\n    };\n    console.log('categories', categories);\n\n    // 6. Generate feedback based on overall score\n    const feedback = this.generateFeedback(overallScore);\n    console.log('feedback', feedback);\n\n    // Create and return the complete score result\n    const scoreResult: ScoreResult = {\n      totalScore: overallScore,\n      categories,\n      feedback,\n      timestamp: Date.now(),\n    };\n    console.log('scoreResult', scoreResult);\n\n    // Emit score calculated event\n    this.emit('score-calculated', scoreResult);\n\n    return scoreResult;\n  }\n\n  /**\n   * Calculate accuracy score based on path similarity\n   * @param example - Example drawing\n   * @param attempt - Attempt drawing\n   * @param constraintBox - Optional constraint box size\n   * @returns Normalized score (0-1)\n   */\n  private calculateAccuracyScore(\n    example: DrawingData,\n    attempt: DrawingData,\n    constraintBox?: ConstraintBoxSize\n  ): number {\n    // First, normalize both drawings to same scale for comparison\n    const normalizedExample = this.normalizeDrawing(example);\n    const normalizedAttempt = this.normalizeDrawing(attempt);\n\n    // Prepare for scoring\n    let pathSimilarityScore = 0;\n    let constraintAdherenceScore = 1; // Default to perfect if no constraint box\n\n    // Calculate path similarity using Hausdorff distance\n    pathSimilarityScore = this.calculatePathSimilarity(normalizedExample, normalizedAttempt);\n\n    // If constraint box provided, check if strokes stayed inside\n    if (constraintBox) {\n      constraintAdherenceScore = this.calculateConstraintAdherence(attempt, constraintBox);\n    }\n\n    // Combine path similarity (75%) and constraint adherence (25%)\n    return pathSimilarityScore * 0.75 + constraintAdherenceScore * 0.25;\n  }\n\n  /**\n   * Calculate strokes score based on number and pattern of strokes\n   * @param example - Example drawing\n   * @param attempt - Attempt drawing\n   * @returns Normalized score (0-1)\n   */\n  private calculateStrokesScore(example: DrawingData, attempt: DrawingData): number {\n    // Compare stroke counts\n    const exampleStrokeCount = example.strokes.length;\n    const attemptStrokeCount = attempt.strokes.length;\n\n    // Calculate stroke count similarity (how close the counts are)\n    const countDifference = Math.abs(exampleStrokeCount - attemptStrokeCount);\n    const maxStrokes = Math.max(exampleStrokeCount, attemptStrokeCount);\n    const strokeCountScore = maxStrokes > 0 ? Math.max(0, 1 - countDifference / maxStrokes) : 1;\n\n    // Compare stroke lengths\n    const strokeLengthScore = this.compareStrokeLengths(example, attempt);\n\n    // Combine stroke count (50%) and stroke length (50%) scores\n    return strokeCountScore * 0.5 + strokeLengthScore * 0.5;\n  }\n\n  /**\n   * Calculate timing score based on rhythm and pace\n   * @param example - Example drawing\n   * @param attempt - Attempt drawing\n   * @returns Normalized score (0-1)\n   */\n  private calculateTimingScore(example: DrawingData, attempt: DrawingData): number {\n    // Compare total drawing time\n    const timingRatioScore = this.compareTimingRatio(example, attempt);\n\n    // Compare stroke timing patterns\n    const strokeTimingScore = this.compareStrokeTimingPatterns(example, attempt);\n\n    // Combine total time (40%) and stroke timing (60%) scores\n    return timingRatioScore * 0.4 + strokeTimingScore * 0.6;\n  }\n\n  /**\n   * Calculate path similarity between two drawings\n   * @param example - Normalized example drawing\n   * @param attempt - Normalized attempt drawing\n   * @returns Similarity score (0-1)\n   */\n  private calculatePathSimilarity(example: DrawingData, attempt: DrawingData): number {\n    // If either drawing has no strokes, return 0\n    if (example.strokes.length === 0 || attempt.strokes.length === 0) {\n      return 0;\n    }\n\n    // We'll use a simplified version of the Hausdorff distance\n    // Get all points from both drawings\n    const examplePoints = this.getAllPoints(example);\n    const attemptPoints = this.getAllPoints(attempt);\n\n    if (examplePoints.length === 0 || attemptPoints.length === 0) {\n      return 0;\n    }\n\n    // Calculate average minimum distance from attempt to example\n    let totalDistance = 0;\n\n    for (const attemptPoint of attemptPoints) {\n      // Find minimum distance to any example point\n      let minDistance = Number.MAX_VALUE;\n\n      for (const examplePoint of examplePoints) {\n        const distance = this.calculateDistance(attemptPoint, examplePoint);\n        minDistance = Math.min(minDistance, distance);\n      }\n\n      totalDistance += minDistance;\n    }\n\n    // Average minimum distance\n    const avgDistance = totalDistance / attemptPoints.length;\n\n    // Convert to similarity score (0-1)\n    // The smaller the distance, the higher the similarity\n    // Using an exponential decay function to convert distance to similarity\n    const similarityScore = Math.exp(-avgDistance * 5);\n\n    return similarityScore;\n  }\n\n  /**\n   * Calculate if strokes stay within constraint box\n   * @param attempt - Attempt drawing\n   * @param constraintBox - Constraint box size\n   * @returns Adherence score (0-1)\n   */\n  private calculateConstraintAdherence(\n    attempt: DrawingData,\n    constraintBox: ConstraintBoxSize\n  ): number {\n    // Count points outside constraint box\n    let totalPoints = 0;\n    let pointsOutside = 0;\n\n    // Center of the canvas (assuming constraint box is centered)\n    const centerX = attempt.width / 2;\n    const centerY = attempt.height / 2;\n\n    // Boundaries of constraint box\n    const leftBound = centerX - constraintBox.width / 2;\n    const rightBound = centerX + constraintBox.width / 2;\n    const topBound = centerY - constraintBox.height / 2;\n    const bottomBound = centerY + constraintBox.height / 2;\n\n    // Check each point in each stroke\n    for (const stroke of attempt.strokes) {\n      for (const point of stroke.points) {\n        totalPoints++;\n\n        // Check if point is outside constraint box\n        if (\n          point.x < leftBound ||\n          point.x > rightBound ||\n          point.y < topBound ||\n          point.y > bottomBound\n        ) {\n          pointsOutside++;\n        }\n      }\n    }\n\n    // Calculate adherence score (1 - percentage of points outside)\n    return totalPoints > 0 ? 1 - pointsOutside / totalPoints : 1;\n  }\n\n  /**\n   * Compare the length patterns of strokes\n   * @param example - Example drawing\n   * @param attempt - Attempt drawing\n   * @returns Similarity score (0-1)\n   */\n  private compareStrokeLengths(example: DrawingData, attempt: DrawingData): number {\n    // If either drawing has no strokes, return 0\n    if (example.strokes.length === 0 || attempt.strokes.length === 0) {\n      return 0;\n    }\n\n    // Calculate relative lengths of strokes in each drawing\n    const exampleLengths = this.calculateRelativeStrokeLengths(example);\n    const attemptLengths = this.calculateRelativeStrokeLengths(attempt);\n\n    // Compare stroke length patterns\n    // We'll use the minimum length of the two arrays\n    const minLength = Math.min(exampleLengths.length, attemptLengths.length);\n\n    if (minLength === 0) {\n      return 0;\n    }\n\n    let totalDifference = 0;\n\n    // Compare each stroke's relative length\n    for (let i = 0; i < minLength; i++) {\n      const lengthDifference = Math.abs(exampleLengths[i] - attemptLengths[i]);\n      totalDifference += lengthDifference;\n    }\n\n    // Add penalty for different number of strokes\n    const countDifference = Math.abs(exampleLengths.length - attemptLengths.length);\n    totalDifference += countDifference * 0.1; // Small penalty for each extra/missing stroke\n\n    // Calculate similarity score (0-1)\n    // The smaller the total difference, the higher the similarity\n    const similarityScore = Math.max(0, 1 - totalDifference / minLength);\n\n    return similarityScore;\n  }\n\n  /**\n   * Compare the total drawing time ratio\n   * @param example - Example drawing\n   * @param attempt - Attempt drawing\n   * @returns Similarity score (0-1)\n   */\n  private compareTimingRatio(example: DrawingData, attempt: DrawingData): number {\n    // If either drawing has no total time, return 0.5 (neutral score)\n    if (example.totalTime <= 0 || attempt.totalTime <= 0) {\n      return 0.5;\n    }\n\n    // Calculate ratio of attempt time to example time\n    const timeRatio = attempt.totalTime / example.totalTime;\n\n    // Ideal ratio is 1.0 (same time)\n    // Score decreases as ratio moves away from 1.0 in either direction\n    // Use a bell curve to score the ratio\n    const score = Math.exp(-Math.pow(Math.log(timeRatio), 2));\n\n    return score;\n  }\n\n  /**\n   * Compare timing patterns between strokes\n   * @param example - Example drawing\n   * @param attempt - Attempt drawing\n   * @returns Similarity score (0-1)\n   */\n  private compareStrokeTimingPatterns(example: DrawingData, attempt: DrawingData): number {\n    // If either drawing has too few strokes, return neutral score\n    if (example.strokes.length < 2 || attempt.strokes.length < 2) {\n      return 0.5;\n    }\n\n    // Calculate relative stroke durations\n    const exampleDurations = this.calculateRelativeStrokeDurations(example);\n    const attemptDurations = this.calculateRelativeStrokeDurations(attempt);\n\n    // Compare duration patterns\n    const minLength = Math.min(exampleDurations.length, attemptDurations.length);\n\n    if (minLength < 2) {\n      return 0.5;\n    }\n\n    let totalDifference = 0;\n\n    // Compare each stroke's relative duration\n    for (let i = 0; i < minLength; i++) {\n      const durationDifference = Math.abs(exampleDurations[i] - attemptDurations[i]);\n      totalDifference += durationDifference;\n    }\n\n    // Calculate similarity score (0-1)\n    const similarityScore = Math.max(0, 1 - totalDifference / minLength);\n\n    return similarityScore;\n  }\n\n  /**\n   * Calculate relative stroke lengths as proportions of total length\n   * @param drawing - Drawing data\n   * @returns Array of relative lengths (0-1)\n   */\n  private calculateRelativeStrokeLengths(drawing: DrawingData): number[] {\n    const lengths: number[] = [];\n    let totalLength = 0;\n\n    // Calculate length of each stroke\n    for (const stroke of drawing.strokes) {\n      let strokeLength = 0;\n\n      // Calculate length by summing distances between consecutive points\n      for (let i = 1; i < stroke.points.length; i++) {\n        const p1 = stroke.points[i - 1];\n        const p2 = stroke.points[i];\n        strokeLength += this.calculateDistance(p1, p2);\n      }\n\n      lengths.push(strokeLength);\n      totalLength += strokeLength;\n    }\n\n    // Calculate relative lengths (as proportion of total length)\n    return lengths.map(length => (totalLength > 0 ? length / totalLength : 0));\n  }\n\n  /**\n   * Calculate relative stroke durations as proportions of total time\n   * @param drawing - Drawing data\n   * @returns Array of relative durations (0-1)\n   */\n  private calculateRelativeStrokeDurations(drawing: DrawingData): number[] {\n    const durations: number[] = [];\n    let totalDuration = 0;\n\n    // Calculate duration of each stroke\n    for (const stroke of drawing.strokes) {\n      const duration = stroke.endTime - stroke.startTime;\n      durations.push(duration);\n      totalDuration += duration;\n    }\n\n    // Calculate relative durations (as proportion of total time)\n    return durations.map(duration => (totalDuration > 0 ? duration / totalDuration : 0));\n  }\n\n  /**\n   * Normalize drawing to common scale for comparison\n   * @param drawing - Drawing data to normalize\n   * @returns Normalized drawing data\n   */\n  private normalizeDrawing(drawing: DrawingData): DrawingData {\n    // If drawing is empty, return a copy as is\n    if (drawing.strokes.length === 0) {\n      return {\n        strokes: [],\n        totalTime: drawing.totalTime,\n        width: drawing.width,\n        height: drawing.height,\n        created: drawing.created,\n      };\n    }\n\n    // Find bounding box of the drawing\n    let minX = Number.MAX_VALUE;\n    let maxX = Number.MIN_VALUE;\n    let minY = Number.MAX_VALUE;\n    let maxY = Number.MIN_VALUE;\n\n    for (const stroke of drawing.strokes) {\n      for (const point of stroke.points) {\n        minX = Math.min(minX, point.x);\n        maxX = Math.max(maxX, point.x);\n        minY = Math.min(minY, point.y);\n        maxY = Math.max(maxY, point.y);\n      }\n    }\n\n    // Calculate dimensions and scale factor\n    const width = maxX - minX;\n    const height = maxY - minY;\n    const scale = width > 0 && height > 0 ? Math.min(1 / width, 1 / height) : 1;\n\n    // Create normalized strokes\n    const normalizedStrokes: StrokeData[] = drawing.strokes.map(stroke => {\n      // Create normalized points\n      const normalizedPoints: Point[] = stroke.points.map(point => {\n        return {\n          x: (point.x - minX) * scale,\n          y: (point.y - minY) * scale,\n          timestamp: point.timestamp,\n          pressure: point.pressure,\n        };\n      });\n\n      // Return normalized stroke\n      return {\n        id: stroke.id,\n        points: normalizedPoints,\n        startTime: stroke.startTime,\n        endTime: stroke.endTime,\n        color: stroke.color,\n        width: stroke.width,\n      };\n    });\n\n    // Return normalized drawing\n    return {\n      strokes: normalizedStrokes,\n      totalTime: drawing.totalTime,\n      width: 1, // Normalized to 0-1 range\n      height: height / width, // Maintain aspect ratio\n      created: drawing.created,\n    };\n  }\n\n  /**\n   * Get all points from a drawing as a flat array\n   * @param drawing - Drawing data\n   * @returns Array of all points\n   */\n  private getAllPoints(drawing: DrawingData): Point[] {\n    const points: Point[] = [];\n\n    for (const stroke of drawing.strokes) {\n      points.push(...stroke.points);\n    }\n\n    return points;\n  }\n\n  /**\n   * Calculate Euclidean distance between two points\n   * @param p1 - First point\n   * @param p2 - Second point\n   * @returns Distance between points\n   */\n  private calculateDistance(p1: Point, p2: Point): number {\n    const dx = p2.x - p1.x;\n    const dy = p2.y - p1.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  /**\n   * Convert normalized score (0-1) to star rating (1-5)\n   * @param score - Normalized score (0-1)\n   * @returns Star rating (1-5)\n   */\n  private normalizedScoreToStars(score: number): number {\n    // Ensure score is in range 0-1\n    const normalizedScore = Math.max(0, Math.min(1, score));\n\n    // Convert to star rating (1-5)\n    // Scale of 0-1 to 1-5: (score * 4) + 1\n    return Math.round(normalizedScore * 4 + 1);\n  }\n\n  /**\n   * Generate feedback message based on score\n   * @param score - Score out of 100\n   * @returns Feedback message\n   */\n  private generateFeedback(score: number): string {\n    // Select feedback template based on score\n    let feedbackCategory: keyof typeof this.FEEDBACK;\n\n    if (score >= 90) {\n      feedbackCategory = 'excellent';\n    } else if (score >= 75) {\n      feedbackCategory = 'veryGood';\n    } else if (score >= 60) {\n      feedbackCategory = 'good';\n    } else if (score >= 40) {\n      feedbackCategory = 'fair';\n    } else {\n      feedbackCategory = 'needsWork';\n    }\n\n    // Choose random feedback from selected category\n    const feedbackOptions = this.FEEDBACK[feedbackCategory];\n    const randomIndex = Math.floor(Math.random() * feedbackOptions.length);\n\n    return feedbackOptions[randomIndex];\n  }\n}\n"],"names":["GameManager","storageManager","audioManager","uiManager","drawingManager","scoreManager","state","currentExercise","currentAttempt","isPlaying","isCreatingExercise","MAX_ATTEMPTS","constructor","options","this","handleCreateExercise","bind","handleLoadExercise","handleExerciseSelected","handleSaveExercise","handleCancelExercise","handleDoneButtonClicked","handleAttemptAnimationComplete","handleBackToMenu","handleTryAgain","startNextAttempt","initialize","console","log","setupEventListeners","setupDrawingCanvas","Promise","resolve","on","exercise","data","attemptNumber","starCount","playStarSound","strokePauseTimer","strokeSoundStarted","setupStrokeSoundListeners","emitter","args","point","y","updateStrokeSound","startStrokeSound","resumeStrokeSound","clearTimeout","setTimeout","pauseStrokeSound","stopStrokeSound","playStrokeSound","canvas","document","querySelector","setCanvas","showWelcomeScreen","showView","reset","parent","parentElement","rect","getBoundingClientRect","ratio","window","devicePixelRatio","width","height","style","enable","exercises","getExercises","length","thumbnails","forEach","thumbnail","getThumbnail","id","updateExerciseList","name","resetHistoryDisplay","showExampleDrawing","adultDrawing","onExampleComplete","off","showScoreScreen","boxSize","calculateConstraintBoxSize","setupAttemptView","playAttemptStartSound","disable","drawingData","getDrawingData","attempts","push","strokes","totalTime","created","Date","now","playAttemptCompleteSound","animateDrawingToHistory","score","calculateScore","saveExerciseResult","playFanfareSound","error","showError","toString","createdAt","highestScore","saveExercise","then","showExerciseSavedConfirmation","catch","cleanupAnimations","innerWidth","innerHeight","baseSize","Math","min","scaleFactor","max","startGameWithExercise","DrawingManager","EventEmitter","context","isDrawing","isEnabled","currentStroke","strokeCounter","startTime","endTime","strokeColor","strokeWidth","canvasElement","createElement","classList","add","getContext","Error","addEventListener","handleTouchStart","handleTouchMove","handleTouchEnd","handleMouseDown","handleMouseMove","handleMouseUp","clearRect","pointerEvents","setStrokeColor","color","setStrokeWidth","event","preventDefault","touch","touches","startStroke","clientX","clientY","force","continueStroke","endStroke","x","pressure","pixelRatio","canvasX","left","canvasY","top","points","timestamp","lineWidth","lineCap","lineJoin","strokeStyle","beginPath","moveTo","emit","lineTo","stroke","getCanvas","ScoreManager","MAX_SCORE","WEIGHTS","accuracy","timing","FEEDBACK","excellent","veryGood","good","fair","needsWork","example","constraintBoxes","finalAttempt","accuracyScore","calculateAccuracyScore","strokesScore","calculateStrokesScore","timingScore","calculateTimingScore","overallScore","round","categories","normalizedScoreToStars","overall","feedback","generateFeedback","scoreResult","totalScore","attempt","constraintBox","normalizedExample","normalizeDrawing","normalizedAttempt","pathSimilarityScore","constraintAdherenceScore","calculatePathSimilarity","calculateConstraintAdherence","exampleStrokeCount","attemptStrokeCount","countDifference","abs","maxStrokes","compareStrokeLengths","compareTimingRatio","compareStrokeTimingPatterns","examplePoints","getAllPoints","attemptPoints","totalDistance","attemptPoint","minDistance","Number","MAX_VALUE","examplePoint","distance","calculateDistance","avgDistance","exp","totalPoints","pointsOutside","centerX","centerY","leftBound","rightBound","topBound","bottomBound","exampleLengths","calculateRelativeStrokeLengths","attemptLengths","minLength","totalDifference","i","timeRatio","pow","exampleDurations","calculateRelativeStrokeDurations","attemptDurations","drawing","lengths","totalLength","strokeLength","p1","p2","map","durations","totalDuration","duration","minX","maxX","MIN_VALUE","minY","maxY","scale","normalizedPoints","dx","dy","sqrt","normalizedScore","feedbackCategory","feedbackOptions","floor","random"],"mappings":"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"}